<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue面试题</title>
      <link href="/2024/10/07/vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/10/07/vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="v-text-与-与v-html的区别？"><a href="#v-text-与-与v-html的区别？" class="headerlink" title="v-text 与 与v-html的区别？"></a>v-text 与 {{}}与v-html的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;将数据解析为纯文本，不能显示输出的html</span><br><span class="line">v-html 可以渲染输出html</span><br><span class="line">v-text 将数据解析为纯文本，不能输出真正的html，与花括号的区别是页面加载时不显示双花括号。</span><br><span class="line">v-text指令：</span><br><span class="line">作用：操作网页元素中的纯文本内容。&#123;&#123;&#125;&#125;是他的另一种写法。</span><br><span class="line">v-text与&#123;&#123;&#125;&#125;的区别：</span><br><span class="line">v-text与&#123;&#123;&#125;&#125;等价，&#123;&#123;&#125;&#125;叫模板插值，v-text叫指令。</span><br><span class="line">有一点区别就是，在渲染的数据比较多的时候，可能回把大括号显示出来。俗称屏幕闪动。</span><br></pre></td></tr></table></figure><h2 id="v-on可以绑定多个方法吗？"><a href="#v-on可以绑定多个方法吗？" class="headerlink" title="v-on可以绑定多个方法吗？"></a>v-on可以绑定多个方法吗？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以，如果绑定多个事件，可以用键值对的形式，事件类型：事件名。如果绑定多个相同事件，可以用逗号分隔开。</span><br></pre></td></tr></table></figure><h2 id="Vue循环的key作用"><a href="#Vue循环的key作用" class="headerlink" title="Vue循环的key作用?"></a>Vue循环的key作用?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key值的存在是保证了唯一性，Vue在执行时，会对节点进行检查，如果没有key值，那么vue检查到这里有dom节点，就会对内容清空并赋新值，如果有key值存在，那么会对新老节点进行对比，比较两者key是否相同，进行调换位置或删除操作。</span><br></pre></td></tr></table></figure><h2 id="什么时计算属性？"><a href="#什么时计算属性？" class="headerlink" title="什么时计算属性？"></a>什么时计算属性？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算属性是用来声明式的描述一个值依赖于其他值，当她依赖的这个值发生变化时，就更新DOM，当在模板中把数据绑定到一个计算属性上时，vue会在它依赖的如何值导致该计算属性改变时更新DOM，每个计算属性都包括一个getter和setter，读取时触发getter，修改时触发setter。</span><br></pre></td></tr></table></figure><h2 id="vue跨越的解决方法？"><a href="#vue跨越的解决方法？" class="headerlink" title="vue跨越的解决方法？"></a>vue跨越的解决方法？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、.后台更改header</span><br><span class="line">2、使用jq提供的jsonp</span><br><span class="line">3、用http-proxy-middleware（配置代理服务器的中间件）</span><br></pre></td></tr></table></figure><h2 id="Vue的生命周期并描述？"><a href="#Vue的生命周期并描述？" class="headerlink" title="Vue的生命周期并描述？"></a>Vue的生命周期并描述？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vue的生命是周期就是vue实例创建到实例销毁的过程。期间会8个钩子函数的调用。</span><br><span class="line">BeforeCreate</span><br><span class="line">Created</span><br><span class="line">BeforeMount</span><br><span class="line">Mounted</span><br><span class="line">BeforeUpdate</span><br><span class="line">Updated</span><br><span class="line">BeforeDestroy</span><br><span class="line">Destroyed</span><br></pre></td></tr></table></figure><h2 id="Vue路由的实现？"><a href="#Vue路由的实现？" class="headerlink" title="Vue路由的实现？"></a>Vue路由的实现？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前端路由就是更新视图但不请求页面，</span><br><span class="line">利用锚点完成切换，页面不会刷新</span><br><span class="line">官网推荐用vue-router.Js来引入路由模块。</span><br><span class="line">定义路由组件</span><br><span class="line">定义路由，使用component进行路由映射组件，用name导航到对应路由</span><br><span class="line">创建router实例，传入routes配置</span><br><span class="line">创建和挂载根实例</span><br><span class="line">用router-link设置路由跳转。</span><br></pre></td></tr></table></figure><h2 id="Vue中如何进行动态路由设置？有哪些方式？怎么获取传递过来的数据？"><a href="#Vue中如何进行动态路由设置？有哪些方式？怎么获取传递过来的数据？" class="headerlink" title="Vue中如何进行动态路由设置？有哪些方式？怎么获取传递过来的数据？"></a>Vue中如何进行动态路由设置？有哪些方式？怎么获取传递过来的数据？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">动态路由也可以叫路由传参，</span><br><span class="line">动态路由有query和params两种方式传参</span><br><span class="line">Query用path引入，params用name引入，query用this.$route.query.name接受参数</span><br><span class="line">Params用this.$route.params.name接受参数。</span><br></pre></td></tr></table></figure><h2 id="首屏加载速度慢怎么优化？"><a href="#首屏加载速度慢怎么优化？" class="headerlink" title="首屏加载速度慢怎么优化？"></a>首屏加载速度慢怎么优化？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、网络</span><br><span class="line">当我们的网络请求较多时，浏览器增加首屏渲染速度，如果大量的数据请求慢 会导致也页面渲染慢减少网络请求</span><br><span class="line">减少网络请求：使用图片懒加载，只发送用户视口可见的请求</span><br><span class="line">使用缓存：与后端配合进行资源的缓存，如长期不变的logo或定量更新的资源可以采用缓存的形式处理优化。</span><br><span class="line">使用cdn加速：对资源进行托管，保证服务器的响应速度。</span><br><span class="line">2、加载资源方面</span><br><span class="line">路由懒加载：使用路由懒加载的形式，进行资源处理，当我们需要用到该资源的使用才进行资源的加载。      </span><br></pre></td></tr></table></figure><h2 id="Vue路由模式："><a href="#Vue路由模式：" class="headerlink" title="Vue路由模式："></a>Vue路由模式：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Hash：</span><br><span class="line">利用url 的hash值作为路由，通过hashchange监听hash值的变化。</span><br><span class="line">2.History：</span><br><span class="line">通过浏览器的Historyapi实现，但需要后端配置。</span><br><span class="line">3.Abstract：</span><br><span class="line">不用不了解</span><br></pre></td></tr></table></figure><h2 id="虚拟dom："><a href="#虚拟dom：" class="headerlink" title="虚拟dom："></a>虚拟dom：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟dom 是为了提高渲染的性能</span><br></pre></td></tr></table></figure><h2 id="Vue2和3的区别："><a href="#Vue2和3的区别：" class="headerlink" title="Vue2和3的区别："></a>Vue2和3的区别：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue响应式的底层实现不同</span><br><span class="line">生命周期有一定的区别</span><br><span class="line">多个根节点</span><br><span class="line">v - if和v - for优先度不同</span><br><span class="line">vue3新增了组合式api</span><br></pre></td></tr></table></figure><h2 id="v-if和v-show的区别："><a href="#v-if和v-show的区别：" class="headerlink" title="v-if和v-show的区别："></a>v-if和v-show的区别：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">都是控制元素显示隐藏的</span><br><span class="line">v - show是通过css的display实现而v - if是通过对dom操作</span><br></pre></td></tr></table></figure><h2 id="computed和watch的区别："><a href="#computed和watch的区别：" class="headerlink" title="computed和watch的区别："></a>computed和watch的区别：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">computed是有缓存的，当他依赖的属性值发生变化时才发生改变</span><br><span class="line">watch没有缓存，当所监听的数据发生变化时执行回调。</span><br></pre></td></tr></table></figure><h2 id="Vue-中-V-bind-和-V-model-有什么区别？"><a href="#Vue-中-V-bind-和-V-model-有什么区别？" class="headerlink" title="Vue 中 V-bind 和 V-model 有什么区别？"></a>Vue 中 V-bind 和 V-model 有什么区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v-model是动态双向绑定，改变数据的同时，视图中的数据的也会发生改变，基本上用在表单元素上</span><br><span class="line">v-bind是数据绑定，没有双向绑定的效果，任何有效元素上都可以使用</span><br></pre></td></tr></table></figure><h2 id="Vue的导航守卫有哪一些？"><a href="#Vue的导航守卫有哪一些？" class="headerlink" title="Vue的导航守卫有哪一些？"></a>Vue的导航守卫有哪一些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BeforeEach2</span><br><span class="line">beforeReslove6</span><br><span class="line">afterEach7</span><br><span class="line">beforeEnter3</span><br><span class="line">beforeRouteEnter4</span><br><span class="line">beforeRouteUpdate5</span><br><span class="line">beforeRouteLeave1</span><br></pre></td></tr></table></figure><h2 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM?"></a>什么是MVVM?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mvvm是一种设计思想，也就是model，view，viewmodel的缩写。其中model代表的是数据层，view代表的是视图层，而viewmodel是一个连接并同步view和model的对象。他的优点是不需要手动操作dom，复杂的数据状态维护完全交由mvvm统一管理。</span><br><span class="line"></span><br><span class="line">1.MVVM 是Model - View - ViewModel的缩写，是一种设计思想。</span><br><span class="line">其中Model代表的是数据模型，可以在Model中定义数据修改和操作业务逻辑；</span><br><span class="line">View代表UI组件，它负责将数据模型转化为UI展现出来；</span><br><span class="line">ViewModel是一个同步view和Model的对象。</span><br><span class="line"></span><br><span class="line">2.View和Model之间是没有直接的联系的，是通过ViewModel进行交互，</span><br><span class="line">因为Model和ViewModel之间的交互是双向的，所以View数据的变化回同步到Model中，</span><br><span class="line">而Model数据的变化也会立即反应到View上</span><br><span class="line"></span><br><span class="line">3.ViewModel通过双向数据绑定把View和Model连接起来了，所以View和Model之间的同步工作是完全自动的，无需人为的干涉，</span><br><span class="line">因此只需要关注业务逻辑，不需要手动操作Dom，无需关注数据状态同步问题，复杂的数据状态维护完全由MVVM统一管理。</span><br></pre></td></tr></table></figure><h2 id="vue2常用优化性能的方法："><a href="#vue2常用优化性能的方法：" class="headerlink" title="vue2常用优化性能的方法："></a>vue2常用优化性能的方法：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">常用</span><br><span class="line"></span><br><span class="line">1.路由组件的懒加载：这是指将每个路由组件编译成一个小的文件块，只有当用户访问该路由时才请求加载。这样可以减少初始加载时间，提高页面响应速度。</span><br><span class="line"></span><br><span class="line">2.减少外部库的使用：外部库可能会增加应用的体积和依赖，影响性能和维护。在使用外部库之前，应该检查是否有原生的浏览器特性可以实现相同的功能，或者是否有更轻量的替代方案。</span><br><span class="line"></span><br><span class="line">3.使用keep - alive缓存组件：keep - alive是一个内置的抽象组件，可以缓存不活动的组件实例，避免重复渲染和销毁。这对于频繁切换的组件，如标签页、列表项等，可以提高性能和用户体验。</span><br><span class="line"></span><br><span class="line">4.避免不必要的重新渲染：Vue提供了一些方法和选项来控制组件的更新行为，如shouldUpdate、watch、computed等。合理地使用这些特性，可以避免不必要的重新渲染，节省资源和时间。</span><br><span class="line"></span><br><span class="line">5.使用v - if而不是v - show：v - if和v - show都可以用来控制元素的显示和隐藏，但是v - if是条件渲染，只有当条件为真时才会渲染元素，而v - show是条件显示，无论条件如何都会渲染元素，只是改变其CSS属性。因此，如果元素不需要频繁切换显示状态，使用v - if比v - show更节省性能。</span><br><span class="line"></span><br><span class="line">不常用</span><br><span class="line"></span><br><span class="line">6. 使用异步组件：对于一些较大或复杂的组件，可以考虑使用异步组件，将其延迟加载，避免阻塞初始页面渲染。</span><br><span class="line"></span><br><span class="line">7. 合理使用 Vuex：对于大型应用程序，合理使用 Vuex 管理状态，避免组件间状态的传递和混乱，提高代码的可维护性和性能。</span><br><span class="line"></span><br><span class="line">8. 优化网络请求：合并请求、压缩资源、使用 CDN 加速等技术手段，优化网络请求的性能，减少页面加载时间。</span><br><span class="line"></span><br><span class="line">9. 监控和分析：使用性能监控工具和浏览器开发者工具进行性能分析，找出性能瓶颈和优化的空间。</span><br><span class="line"></span><br><span class="line">10. 节流和防抖：对于频繁触发的事件（如滚动、窗口调整），使用节流（throttle）或防抖（debounce）函数来控制事件处理的频率，避免过多的计算和渲染操作。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.使用路由懒加载方式：</span><br><span class="line">在router.js中</span><br><span class="line"></span><br><span class="line">// 导入Vue模块</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">// 导入vue-router模块</span><br><span class="line">import Router from &#x27;vue-router&#x27;</span><br><span class="line">// 使用动态导入语法来实现懒加载</span><br><span class="line">// 假设你有两个路由组件，分别是Home.vue和About.vue，你可以在router.js文件中这样注册它们：</span><br><span class="line">// 这样做的好处是，只有当用户访问对应的路由时，才会加载对应的组件，提高了性能</span><br><span class="line">const Home = () =&gt; import(&#x27;./routes/Home.vue&#x27;);</span><br><span class="line">const About = () =&gt; import(&#x27;./routes/About.vue&#x27;);</span><br><span class="line">// 使用vue-router插件</span><br><span class="line">Vue.use(Router)</span><br><span class="line">// 创建并导出一个Router实例，配置路由规则</span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      // 当用户访问根路径时，渲染Home组件</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      // 当用户访问/about路径时，渲染About组件</span><br><span class="line">      path: &#x27;/about&#x27;,</span><br><span class="line">      component: About</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">这样，当用户访问根路径时，只会加载Home组件的文件块，当用户访问/about路径时，才会加载About组件的文件块。这样可以提高页面的加载速度和性能。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2.使用异步组件方式：</span><br><span class="line">// 定义一个异步组件</span><br><span class="line">const AsyncComp = defineAsyncComponent(&#123;</span><br><span class="line">  // loader是一个返回Promise对象的函数，用于导入组件</span><br><span class="line">  loader: () =&gt; import(&#x27;./Foo.vue&#x27;),</span><br><span class="line">  // loadingComponent是一个组件，用于在加载过程中显示</span><br><span class="line">  loadingComponent: LoadingComponent,</span><br><span class="line">  // delay是一个毫秒数，用于延迟显示loadingComponent</span><br><span class="line">  delay: 200,</span><br><span class="line">  // errorComponent是一个组件，用于在加载失败时显示</span><br><span class="line">  errorComponent: ErrorComponent,</span><br><span class="line">  // timeout是一个毫秒数，用于设置加载超时时间</span><br><span class="line">  timeout: 3000</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">3.使用keep-alive方式:</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;tabs&quot;&gt;</span><br><span class="line">      &lt;!-- 使用v-for指令遍历tabs数组，生成对应的按钮 --&gt;</span><br><span class="line">      &lt;!-- 使用:class指令动态绑定按钮的类名，根据currentTab的值判断是否激活 --&gt;</span><br><span class="line">      &lt;!-- 使用@click指令绑定点击事件，更新currentTab的值 --&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        v-for=&quot;tab in tabs&quot;</span><br><span class="line">        :key=&quot;tab&quot;</span><br><span class="line">        :class=&quot;&#123; active: currentTab === tab &#125;&quot;</span><br><span class="line">        @click=&quot;currentTab = tab&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;&#123; tab &#125;&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 使用keep-alive包裹router-view，缓存不活动的组件实例 --&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // 定义一个tabs数组，存放三个标签页的名称</span><br><span class="line">      tabs: [&#x27;Tab1&#x27;, &#x27;Tab2&#x27;, &#x27;Tab3&#x27;],</span><br><span class="line">      // 定义一个currentTab变量，存放当前选中的标签页的名称</span><br><span class="line">      currentTab: &#x27;Tab1&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// keep-alive组件提供了两个属性来控制哪些组件被缓存，分别是include和exclude。😊</span><br><span class="line"></span><br><span class="line">// include属性可以接受一个字符串或者一个正则表达式，用来匹配需要被缓存的组件的name选项。例如，如果你只想缓存Tab1和Tab2组件，你可以这样写：</span><br><span class="line"></span><br><span class="line">// &lt;keep-alive include=&quot;Tab1,Tab2&quot;&gt;</span><br><span class="line">//   &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">// &lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">// exclude属性可以接受一个字符串或者一个正则表达式，用来匹配不需要被缓存的组件的name选项。例如，如果你想缓存除了Tab3以外的所有组件，你可以这样写：</span><br><span class="line"></span><br><span class="line">// &lt;keep-alive exclude=&quot;Tab3&quot;&gt;</span><br><span class="line">//   &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">// &lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">// 注意，使用include和exclude属性时，需要给组件设置name选项，否则无法匹配。😊</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右键菜单组件</title>
      <link href="/2024/10/07/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6/"/>
      <url>/2024/10/07/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="右键菜单组件"><a href="#右键菜单组件" class="headerlink" title="右键菜单组件"></a>右键菜单组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function Menu(containerRef) &#123;</span><br><span class="line">  const showMenu = ref(false);</span><br><span class="line">  const x = ref(0);</span><br><span class="line">  const y = ref(0);</span><br><span class="line">  const handleContextMenu = (e) =&gt; &#123;</span><br><span class="line">    //阻止浏览器的默认行为</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    // 阻止事件冒泡</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    showMenu.value = true;</span><br><span class="line">    x.value = e.clientX;</span><br><span class="line">    y.value = e.clientY;</span><br><span class="line">  &#125;;</span><br><span class="line">  function closeMenu()&#123;</span><br><span class="line">    showMenu.value = false;</span><br><span class="line">  &#125;</span><br><span class="line">  onMounted(() =&gt; &#123;</span><br><span class="line">    const div = containerRef.value;</span><br><span class="line">    div.addEventListener(&quot;contextmenu&quot;, handleContextMenu);</span><br><span class="line">    // 在捕获阶段处理，防止阻止冒泡</span><br><span class="line">    window.addEventListener(&quot;click&quot;, closeMenu,true);</span><br><span class="line">    window.addEventListener(&quot;contextmenu&quot;, closeMenu,true);</span><br><span class="line">  &#125;);</span><br><span class="line">  onUnmounted(() =&gt; &#123;</span><br><span class="line">    const div = containerRef.value;</span><br><span class="line">    div.removeEventListener(&quot;contextmenu&quot;, handleContextMenu);</span><br><span class="line">    // 在捕获阶段处理，防止阻止冒泡</span><br><span class="line">    div.removeEventListener(&quot;click&quot;, closeMenu,true);</span><br><span class="line">    window.removeEventListener(&quot;contextmenu&quot;, closeMenu,true);</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么实现节流</title>
      <link href="/2024/10/07/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81/"/>
      <url>/2024/10/07/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//节流</span><br><span class="line">//限制函数的执行频率、确保函数再一定时间间隔内只执行一次</span><br><span class="line">//比如：滚动事件、鼠标移动事件</span><br><span class="line"></span><br><span class="line">const throttle =(fn,delay)=&gt;&#123;</span><br><span class="line">    let canRun =true;//触发标记</span><br><span class="line">    return (...args) =&gt; &#123;</span><br><span class="line">        if( !canRun) return;//如果标记为flase，表示定时器未执行，直接return</span><br><span class="line">        canRun = false;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(this,args);</span><br><span class="line">            canRun =true;//当外部函数执行完成后，将标记设置为true，接受下次触发</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么实现防抖</title>
      <link href="/2024/10/07/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96/"/>
      <url>/2024/10/07/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96/</url>
      
        <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//防抖</span><br><span class="line">//限制事件的触发频率，确保只有事件停止触发一段时间后才执行相应的操作</span><br><span class="line">//比如：输入框事件、按钮点击、窗口大小调整</span><br><span class="line"></span><br><span class="line">const debounce = (fn,delay)=&gt;&#123;</span><br><span class="line">    let timeout =null;//存储定时器标记</span><br><span class="line">    return (...args)=&gt;&#123;</span><br><span class="line">        clearTimeout(timeout); //当触发该事件时，清除定时器</span><br><span class="line">        timeout = setTimeout(() =&gt; &#123; //创建一个新的定时器，在delay时间内，执行fn</span><br><span class="line">            fn.apply(this, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写apply</title>
      <link href="/2024/10/07/%E6%89%8B%E5%86%99apply/"/>
      <url>/2024/10/07/%E6%89%8B%E5%86%99apply/</url>
      
        <content type="html"><![CDATA[<h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function myApply(thisArg, args) &#123;</span><br><span class="line">    const key = Symbol(&#x27;key&#x27;)</span><br><span class="line">    thisArg[key] = this</span><br><span class="line">    const res = thisArg[key](...args)</span><br><span class="line">    delete thisArg[key]</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写bind</title>
      <link href="/2024/10/07/%E6%89%8B%E5%86%99bind/"/>
      <url>/2024/10/07/%E6%89%8B%E5%86%99bind/</url>
      
        <content type="html"><![CDATA[<h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myBind(thisArg, ...args) &#123;</span><br><span class="line">    return (...reArg) =&gt; &#123;</span><br><span class="line">        const key = Symbol(&#x27;key&#x27;)</span><br><span class="line">        thisArg[key] = this</span><br><span class="line">        const res = thisArg[key](...args, ...reArg)</span><br><span class="line">        delete thisArg[key]</span><br><span class="line">        return res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写call</title>
      <link href="/2024/10/07/%E6%89%8B%E5%86%99call/"/>
      <url>/2024/10/07/%E6%89%8B%E5%86%99call/</url>
      
        <content type="html"><![CDATA[<h2 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function myCall(thisArg, ...args) &#123;</span><br><span class="line">    const key = Symbol(&#x27;key&#x27;)</span><br><span class="line">    thisArg[key] = this</span><br><span class="line">    const res = thisArg[key](...args)</span><br><span class="line">    delete thisArg[key]</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios封装</title>
      <link href="/2024/10/06/axios%E5%B0%81%E8%A3%85/"/>
      <url>/2024/10/06/axios%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="二次封装axios"><a href="#二次封装axios" class="headerlink" title="二次封装axios"></a>二次封装axios</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 二次封装axios 拦截器</span><br><span class="line"></span><br><span class="line">import axios from &#x27;axios&#x27;</span><br><span class="line">import config from &#x27;../config/index&#x27;</span><br><span class="line">// 设置配置 根据开发 和 生产环境不一样 </span><br><span class="line">const baseUrl = process.env.NODE_ENV === &#x27;development&#x27; ? config.baseUrl.dev : config.baseUrl.pro</span><br><span class="line">class HttpRequst &#123;</span><br><span class="line">  constructor(baseUrl) &#123;</span><br><span class="line">    this.baseUrl = baseUrl</span><br><span class="line">  &#125;</span><br><span class="line">  getInsideConfig () &#123;</span><br><span class="line">    const config = &#123;</span><br><span class="line">      baseURL: this.baseUrl,</span><br><span class="line">      header: &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return config</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors (instance) &#123;</span><br><span class="line">    instance.interceptors.request.use(function (config) &#123;</span><br><span class="line">      // 在发送请求之前做些什么</span><br><span class="line">      console.log(&#x27;拦截处理请求&#x27;);</span><br><span class="line">      return config;</span><br><span class="line">    &#125;, function (error) &#123;</span><br><span class="line">      // 对请求错误做些什么</span><br><span class="line">      return Promise.reject(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    instance.interceptors.response.use(function (response) &#123;</span><br><span class="line">      console.log(&#x27;处理相应&#x27;);</span><br><span class="line">      // 对响应数据做点什么</span><br><span class="line">      return response.data;</span><br><span class="line">    &#125;, function (error) &#123;</span><br><span class="line">      console.log(error);</span><br><span class="line">      // 对响应错误做点什么</span><br><span class="line">      return Promise.reject(error);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  // &#123;</span><br><span class="line">  //   baseURL:&#x27;/rApi&#x27;</span><br><span class="line">  // &#125;</span><br><span class="line">  request (options) &#123;</span><br><span class="line">    // 请求</span><br><span class="line">    // /api/getList  /api/getHome</span><br><span class="line">    const instanse = axios.create()</span><br><span class="line">    // 技巧</span><br><span class="line">    // /api // api1</span><br><span class="line">    options = &#123; ...(this.getInsideConfig()), ...options &#125;</span><br><span class="line">    // console.log(options);</span><br><span class="line">    this.interceptors(instanse)</span><br><span class="line">    return instanse(options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default new HttpRequst(baseUrl)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> axios </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么实现小时定时器</title>
      <link href="/2024/09/29/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%B0%8F%E6%97%B6%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2024/09/29/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%B0%8F%E6%97%B6%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="小时定时器"><a href="#小时定时器" class="headerlink" title="小时定时器"></a>小时定时器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function hoursSetTime(fn = () =&gt; &#123;&#125;) &#123;</span><br><span class="line">  let date = new Date();</span><br><span class="line">  let dateIntegralPoint = new Date();</span><br><span class="line">  dateIntegralPoint.setHours(date.getHours() + 1);</span><br><span class="line">  dateIntegralPoint.setMinutes(0);</span><br><span class="line">  dateIntegralPoint.setSeconds(0);</span><br><span class="line">  const setTimeouts = setTimeout(function () &#123;</span><br><span class="line">    fn();</span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      fn();</span><br><span class="line">    &#125;, 60 * 60 * 1000);</span><br><span class="line">    clearTimeout(setTimeouts);</span><br><span class="line">  &#125;, dateIntegralPoint - date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝塔定时请求git，拉取最新git代码脚本</title>
      <link href="/2024/09/27/%E5%AE%9D%E5%A1%94%E5%AE%9A%E6%97%B6%E8%AF%B7%E6%B1%82git%EF%BC%8C%E6%8B%89%E5%8F%96%E6%9C%80%E6%96%B0git%E4%BB%A3%E7%A0%81%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/09/27/%E5%AE%9D%E5%A1%94%E5%AE%9A%E6%97%B6%E8%AF%B7%E6%B1%82git%EF%BC%8C%E6%8B%89%E5%8F%96%E6%9C%80%E6%96%B0git%E4%BB%A3%E7%A0%81%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="shell-定时脚本"><a href="#shell-定时脚本" class="headerlink" title="shell 定时脚本"></a>shell 定时脚本</h2><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano name.sh</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 设置远程仓库的URL和本地仓库的目录</span><br><span class="line">REPO_URL=&quot;远程仓库的URL&quot;</span><br><span class="line">LOCAL_REPO_DIR=&quot;本地仓库的目录&quot;</span><br><span class="line"></span><br><span class="line"># 配置文件路径</span><br><span class="line">CONFIG_FILE=&quot;/path/my_script_config.conf&quot;</span><br><span class="line"></span><br><span class="line"># 进入本地仓库目录</span><br><span class="line">cd $LOCAL_REPO_DIR</span><br><span class="line"></span><br><span class="line">if [ -f &quot;$CONFIG_FILE&quot; ]; then</span><br><span class="line">    # 如果存在，读取变量值</span><br><span class="line">    source &quot;$CONFIG_FILE&quot;</span><br><span class="line">else</span><br><span class="line">    # 如果不存在，创建配置文件并写入默认值</span><br><span class="line">    echo &quot;MY_VARIABLE=default_value&quot; &gt; &quot;$CONFIG_FILE&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 初始化或更新本地仓库的远程配置</span><br><span class="line">git remote set-url origin $REPO_URL</span><br><span class="line">git fetch --all</span><br><span class="line"></span><br><span class="line"># 上一次检查的commit</span><br><span class="line">MY_VARIABLE=$(git rev-parse HEAD)</span><br><span class="line"></span><br><span class="line"># 无限循环，定期检查更新</span><br><span class="line">while true; do</span><br><span class="line">    # 拉取远程仓库的最新信息</span><br><span class="line">    git fetch --all</span><br><span class="line"></span><br><span class="line">    # 获取最新的commit</span><br><span class="line">    NEW_COMMIT=$(git rev-parse @&#123;u&#125;)</span><br><span class="line"></span><br><span class="line">    # 比较两次的commit，检查是否有更新</span><br><span class="line">    if [ &quot;$NEW_COMMIT&quot; != &quot;$MY_VARIABLE&quot; ]; then</span><br><span class="line">            echo &quot;远程仓库有更新！&quot;</span><br><span class="line">        # 执行更新脚本</span><br><span class="line">        git reset --hard origin/main</span><br><span class="line">        git pull</span><br><span class="line">        git branch -m main</span><br><span class="line"></span><br><span class="line">        # 更新MY_VARIABLE为最新的commit</span><br><span class="line">        MY_VARIABLE=$NEW_COMMIT</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 等待一段时间再次检查，例如每60秒检查一次</span><br><span class="line">    sleep 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h2><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/name.service</span><br></pre></td></tr></table></figure><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=name</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">ExecStart= sudo /path/name.sh</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h3 id="设置开机自启动-1"><a href="#设置开机自启动-1" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable name.service</span><br></pre></td></tr></table></figure><h3 id="启动开机自启动"><a href="#启动开机自启动" class="headerlink" title="启动开机自启动"></a>启动开机自启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start name.service</span><br></pre></td></tr></table></figure><h3 id="更新开机自启动配置"><a href="#更新开机自启动配置" class="headerlink" title="更新开机自启动配置"></a>更新开机自启动配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload name.service</span><br></pre></td></tr></table></figure><h3 id="查看开机自启动状态"><a href="#查看开机自启动状态" class="headerlink" title="查看开机自启动状态"></a>查看开机自启动状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status name.service</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端如何实现埋点上报？</title>
      <link href="/2024/09/25/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5%EF%BC%9F/"/>
      <url>/2024/09/25/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%8B%E7%82%B9%E4%B8%8A%E6%8A%A5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只有了解用户，才能服务好用户，那么我们该如何去了解用户呢？<br>最直接有效的方式就是了解用户的行为，了解用户在网站中做了什么，呆了多久。<br>而要去实现这一操作，这就涉及到我们前端的埋点了</p><h2 id="埋点方式"><a href="#埋点方式" class="headerlink" title="埋点方式"></a>埋点方式</h2><p>在聊如何进行埋点前，先介绍下什么是埋点？</p><p>所谓 埋点 是 数据采集领域（尤其是用户行为数据采集领域）的术语，指的是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程 。比如用户某个 icon 点击次数、观看某个视频的时长等等。<br>埋点的技术实质，是 先监听软件应用运行过程中的事件，当需要关注的事件发生时进行判断和捕获。<br>特别注意需要明确 事件发生时间点、判别条件，这里如果遇到不清楚的，需要和开发沟通清楚，避免采集数据与理想存在差异。例如：期望采集某个app的某个广告的有效曝光数，有效曝光的判别条件是停留时长超过 1 秒且有效加载出广告内容。</p><p>基于此我们可以知道埋点是实际上是对特定事件或者行为的数据监控和上报，常见的埋点上报方式有 ajax，img，navigator.sendBeacon 下面介绍下这三种埋点上报方式。</p><h2 id="基于-ajax-的埋点上报"><a href="#基于-ajax-的埋点上报" class="headerlink" title="基于 ajax 的埋点上报"></a>基于 ajax 的埋点上报</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>埋点实际上是对关键节点的数据进行上报是和服务端交互的一个过程，所以我们可以和后端约定一个接口通过 ajax 去进行数据上报。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以封装一个方法，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function buryingPointAjax(data) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 创建ajax请求</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line">    // 定义请求接口</span><br><span class="line">    xhr.open(&quot;post&quot;, &#x27;/buryingPoint&#x27;, true);</span><br><span class="line">    // 发送数据</span><br><span class="line">    xhr.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时，直接调用即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let info = &#123;&#125;</span><br><span class="line">buryingPointAjax(info) // 这样就成功上报了info的对象</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>一般而言，埋点域名并不是当前域名，因此请求会存在跨域风险，且如果 ajax 配置不正确可能会浏览器拦截。因此使用 ajax 这类请求并不是万全之策。</p><h2 id="基于-img-的埋点上报"><a href="#基于-img-的埋点上报" class="headerlink" title="基于 img 的埋点上报"></a>基于 img 的埋点上报</h2><p>上面可以看到如果使用 ajax 的话，会存在跨域的问题。而且数据上报前端主要是负责将数据传递到后端，并不过分强调前后端交互。<br>因此我们可以通过一些支持跨域的标签去实现数据上报功能。<br>script，link，img 就是我们上报的数据的最好对象。<br>先说结论，这里推荐使用 img 标签去实现。</p><h3 id="script-及-link-的缺陷"><a href="#script-及-link-的缺陷" class="headerlink" title="script 及 link 的缺陷"></a>script 及 link 的缺陷</h3><p>因为埋点涉及到请求，因此我们需要保证 script 和 link 标签的 src 可以正常请求。<br>如果需要请求 script 和 link，我们需要将标签挂载到页面上。</p><h4 id="验证缺陷"><a href="#验证缺陷" class="headerlink" title="验证缺陷"></a>验证缺陷</h4><p>不妨验证下，我们在管理台中加入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = document.createElement(&#x27;script&#x27;)</span><br><span class="line">a.src = &#x27;https://lf-headquarters-speed.yhgfb-cn-static.com/obj/rc-client-security/web/stable/1.0.0.28/bdms.js&#x27;</span><br></pre></td></tr></table></figure><p>创建一个 script 标签，未挂载中页面上，并不会发起请求<br><img src="/images/post/6528ff613ab7a.jpg"></img><br>当我们将这个标签挂载中页面上时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.appendChild(a)</span><br></pre></td></tr></table></figure><p>这时发起了请求<br><img src="/images/post/64e71aa225ecf.jpg"></img></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>当我们使用 script 和 link 进行埋点上报时，需要挂载到页面上，而反复操作 dom 会造成页面性能受影响，而且载入 js&#x2F;css 资源还会阻塞页面渲染，影响用户体验 。</p><p>因此对于需要频繁上报的埋点而言，script 和 link 并不合适。</p><h3 id="基于-img-做埋点上报"><a href="#基于-img-做埋点上报" class="headerlink" title="基于 img 做埋点上报"></a>基于 img 做埋点上报</h3><p>通常使用 img 标签去做埋点上报，img 标签加载并不需要挂载到页面上，基于 js 去 new image()，设置其 src 之后就可以直接请求图片。</p><h4 id="验证-img-优势"><a href="#验证-img-优势" class="headerlink" title="验证 img 优势"></a>验证 img 优势</h4><p>控制台去创建一个 image 标签，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var img=new Image();</span><br><span class="line">img.src=&quot;https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/MaskGroup.13dfc4f1.png&quot;;</span><br></pre></td></tr></table></figure><p>可以看到即便未被挂载到页面上依旧发起了请求。<br><img src="/images/post/64e71a2dcdb8c.jpg"></img></p><h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>因此当我们做埋点上报时，使用 img 是一个不错的选择。<br>1.img 兼容性好<br>2.无需挂载到页面上，反复操作 dom<br>3.img 的加载不会阻塞 html 的解析，但 img 加载后并不渲染，它需要等待 Render Tree 生成完后才和 4.Render Tree 一起渲染出来</p><div class="note warning flat"><p>注：通常埋点上报会使用 gif 图，合法的 GIF 只需要 43 个字节</p></div><h2 id="基于-Navigator-sendBeacon-的埋点上报"><a href="#基于-Navigator-sendBeacon-的埋点上报" class="headerlink" title="基于 Navigator.sendBeacon 的埋点上报"></a>基于 Navigator.sendBeacon 的埋点上报</h2><p>Navigator.sendBeacon是目前通用的埋点上报方案，Navigator.sendBeacon 方法接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。</p><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>navigator.sendBeacon() 方法可用于通过 HTTP POST 将少量数据 异步 传输到 Web 服务器。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>它主要用于将统计数据发送到 Web 服务器，同时避免了用传统技术（如：XMLHttpRequest）发送分析数据的一些问题。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>sendBeacon如果成功进入浏览器的发送队列后，会返回true；如果受到队列总数、数据大小的限制后，会返回false。返回 ture 后，只是表示进入了发送队列，浏览器会尽力保证发送成功，但是否成功了，不会再有任何返回值。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/images/post/64e71a2dc8fc5.jpg"></img><br>这里发了一个 post 请求，将小量的数据发到服务端，用于统计数据<br><img src="/images/post/64e71a2dcafde.jpg"></img></p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>相较于 img 标签，使用 navigator.sendBeacon 会更规范，数据传输上可传输资源类型会更多。</p><p>对于 ajax 在页面卸载时上报，ajax 有可能没上报完，页面就卸载了导致请求中断，因此 ajax 处理这种情况时必须作为同步操作.</p><p>sendBeacon 是异步的，不会影响当前页到下一个页面的跳转速度，且不受同域限制。这个方法还是异步发出请求，但是请求与当前页面脱离关联，作为浏览器的任务，因此可以保证会把数据发出去，不拖延卸载流程。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>该方法在支付宝中可能会被拦截，如果发现支付宝数据上报异常，可以尝试排查这块。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前端埋点上报常使用ajax，img，navigator.sendBeacon。</p><p>不推荐使用ajax。</p><p>如果考虑兼容性的话，img是不二之选。</p><p>目前最合适的方案是navigator.sendBeacon，不仅是异步的，而且不受同域限制，而且作为浏览器的任务，因此可以保证会把数据发出去，不影响页面卸载。</p><h2 id="常见埋点行为"><a href="#常见埋点行为" class="headerlink" title="常见埋点行为"></a>常见埋点行为</h2><h3 id="点击触发埋点"><a href="#点击触发埋点" class="headerlink" title="点击触发埋点"></a>点击触发埋点</h3><p>绑定点击事件，当点击目标元素时，触发埋点上报。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function clickButton(url, data) &#123;</span><br><span class="line">    navigator.sendBeacon(url, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面停留时间上报埋点"><a href="#页面停留时间上报埋点" class="headerlink" title="页面停留时间上报埋点"></a>页面停留时间上报埋点</h3><p>路由文件中，初始化一个 startTime，当页面离开时通过路由守卫计算停留时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let url = &#x27;&#x27;// 上报地址</span><br><span class="line">let startTime = Date.now()</span><br><span class="line">let currentTime = &#x27;&#x27;</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    if (to) &#123;</span><br><span class="line">        currentTime = Date.now()</span><br><span class="line">        stayTime = parseInt(currentTime - startTime)</span><br><span class="line">        navigator.sendBeacon(url, &#123;time: stayTime&#125;)</span><br><span class="line">        startTime = Date.now()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="错误监听埋点"><a href="#错误监听埋点" class="headerlink" title="错误监听埋点"></a>错误监听埋点</h3><p>通过监听函数去接收错误信息。</p><h3 id="vue错误捕获"><a href="#vue错误捕获" class="headerlink" title="vue错误捕获"></a>vue错误捕获</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.config.errorHandler = (err) =&gt; &#123; </span><br><span class="line">    navigator.sendBeacon(url, &#123;error: error.message, text: &#x27;vue运行异常&#x27; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JS异常与静态资源加载异常"><a href="#JS异常与静态资源加载异常" class="headerlink" title="JS异常与静态资源加载异常"></a>JS异常与静态资源加载异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;error&#x27;, (error) =&gt; &#123; </span><br><span class="line">    if (error.message) &#123; </span><br><span class="line">        navigator.sendBeacon(url, &#123;error: error.message, text: &#x27;js执行异常&#x27; &#125;)</span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        navigator.sendBeacon(url, &#123;error: error.filename, text: &#x27;资源加载异常&#x27; &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;, true)</span><br></pre></td></tr></table></figure><h3 id="请求错误捕获"><a href="#请求错误捕获" class="headerlink" title="请求错误捕获"></a>请求错误捕获</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(</span><br><span class="line">  (response) =&gt; &#123;</span><br><span class="line">    if (response.code == 200) &#123;</span><br><span class="line">      return Promise.resolve(response);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return Promise.reject(response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    // 返回错误逻辑</span><br><span class="line">    navigator.sendBeacon(url, &#123;error: error, text: &#x27;请求错误异常&#x27; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="内容可见埋点"><a href="#内容可见埋点" class="headerlink" title="内容可见埋点"></a>内容可见埋点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 可见性发生变化后的回调 </span><br><span class="line">function callback(data) &#123; </span><br><span class="line">    navigator.sendBeacon(url, &#123; target: data[0].target, text: &#x27;内容可见&#x27; &#125;) </span><br><span class="line">&#125; </span><br><span class="line">// 交叉观察器配置项 </span><br><span class="line">let options = &#123;&#125;; </span><br><span class="line">// 生成交叉观察器 </span><br><span class="line">const observer = new IntersectionObserver(callback); </span><br><span class="line">// 获取目标节点 </span><br><span class="line">let target = document.getElementById(&quot;target&quot;); </span><br><span class="line">// 监听目标元素 </span><br><span class="line">observer.observe(target);</span><br></pre></td></tr></table></figure><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>开发的时候可以封装这三种上报方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// sendBeacon 上报</span><br><span class="line">export async function sendBeacon( &#123;url = &#x27;&#x27;, params &#125;: reportParams) &#123;</span><br><span class="line">    if (navigator?.sendBeacon &amp;&amp; url) &#123;</span><br><span class="line">      const isSuccess = await navigator?.sendBeacon(url, JSON.stringify(params));</span><br><span class="line">      if (isSuccess) return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// img 上报</span><br><span class="line">export function sendImg(&#123; img = &#x27;&#x27;, params &#125;: reportParams) &#123;</span><br><span class="line">    return new Promise&lt;boolean&gt;((resolve, reject) =&gt; &#123;</span><br><span class="line">        const imageData  = objectToQueryString(params)</span><br><span class="line">        const img_o = new Image();</span><br><span class="line">        img_o.onload = () =&gt; resolve(true);</span><br><span class="line">        img_o.onerror = () =&gt; reject(false);</span><br><span class="line">        img_o.src = `$&#123;img&#125;?$&#123;imageData&#125;`;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ajax 上报</span><br><span class="line">export function sendAjax(&#123; req = &#x27;&#x27;, params &#125;: reportParams) &#123;</span><br><span class="line">    return new Promise&lt;boolean&gt;((resolve, reject) =&gt; &#123;</span><br><span class="line">        if (req) &#123;</span><br><span class="line">            postAction(req, params)</span><br><span class="line">                .then(() =&gt; resolve(true))</span><br><span class="line">                .catch(() =&gt; reject(false));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reject(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候再导出一个真实上报函数，有由用户决定使用什么上报组合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 基础上报函数</span><br><span class="line">export async function reportEvent(params: reportParams, reportType:string[] = [IMG, BEACON, AJAX]) &#123;</span><br><span class="line">    let finalType = false</span><br><span class="line">    for (const key in reportType) &#123;</span><br><span class="line">        if (!finalType) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                await EVENT_REPORT_FUNCTION_MAP[key](params).then(()=&gt;&#123;</span><br><span class="line">                    finalType = true</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">                console.error(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return finalType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 数据埋点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈性能优化之图片压缩、加载和格式选择</title>
      <link href="/2024/09/22/%E6%B5%85%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E3%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%A0%BC%E5%BC%8F%E9%80%89%E6%8B%A9/"/>
      <url>/2024/09/22/%E6%B5%85%E8%B0%88%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E3%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%A0%BC%E5%BC%8F%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>在认识图片优化前，我们先了解下 【二进制位数】与【色彩呈现】的关系。</p><h2 id="二进制位数与色彩"><a href="#二进制位数与色彩" class="headerlink" title="二进制位数与色彩"></a>二进制位数与色彩</h2><p>在计算机中，一般用二进制数来表示像素。在不同的图片格式中，像素与二进制位数之间对应的关系是不同的。一个像素对应的二进制位数越多，它能表示的颜色种类就丰富，成像效果也就越精致，图片所需的存储空间相应也会越大。<br><img src="/images/post/6355019ae9db4.png"></img><br>目前市场上优化图片资源的方式有很多，如压缩图片、选择正确格式、 CDN 加速、懒加载等。</p><h2 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h2><p>压缩图片相信是大家第一时间想到的方案。像我们比较熟悉的 tinpng，他的原理是通过有”选择性”地减少图像所要存储的颜色数量，来减少图片所要存储的内存。</p><div class="note info flat"><p>“当你上传 PNG(便携式网络图形)文件时，图像中的类似颜色被组合在一起这种技术称为“量化”。通过减少颜色数量，可以将 24 位 PNG 文件转换为0小得多的8位索引颜色图像。”</p></div><p><img src="/images/post/6355019d177bd.png"></img><br>我们来看下样例：<br><img src="/images/post/6355087a5e6d5.png"></img><br>细节展示：<br><img src="/images/post/635501a1f3d53.png"></img></p><h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><p><img src="/images/post/6355131a9d264.png"></img></p><h3 id="JPEG-JPG"><a href="#JPEG-JPG" class="headerlink" title="JPEG &#x2F; JPG"></a>JPEG &#x2F; JPG</h3><p>JPEG 是最常用的图像文件格式。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>    <li>支持极高的压缩率，可使文件传输、下载、预览速度大大加快。</li>    <li>利用可变的压缩比可以控制文件大小。</li>    <li>能够轻松地处理 1600 万种颜色，可以很好地再现全彩色的图像。</li></ul><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>JPG 的有损压缩在 轮播图 和 背景图 的展示上确实很难看出破绽，但当它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的 图片模糊 会相当明显。因此不适宜用该格式来显示 高清晰度 和 线条感较强 的图像。</p><p>除此之外， JPG 并不支持对有透明度要求的图像进行显示，如果需要显示 透明图片 还是需要另寻它路。<br><img src="/images/post/635501a4c52bb.png"></img></p><h4 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h4><p>JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的 背景图、轮播图或 预览图 出现。打开某电商网站首页，即可看到大图片的处理几乎都是使用了 JPG。<br><img src="/images/post/635501a6b0034.png"></img></p><h3 id="PNG-8-与-PNG-24"><a href="#PNG-8-与-PNG-24" class="headerlink" title="PNG-8 与 PNG-24"></a>PNG-8 与 PNG-24</h3><p>png 是一种采用无损压缩算法的位图格式。</p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul>    <li>无损压缩</li>    <li>完全支持 alpha 透明度。</li>    <li>可以重复保存且不降低图像质量。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>体积太大<br><img src="/images/post/6355096610cf0.png"></img></p><h4 id="业务场景-1"><a href="#业务场景-1" class="headerlink" title="业务场景"></a>业务场景</h4><p>理论上来说，当你追求最佳的显示效果(详情展示图、图片有放大需求、摄影作品等)，并且不在意存储大小或所需带宽时，可以使用 PNG-24。但实践当中，为了避免文件体积过大的问题，我们一般不用 PNG 去处理较复杂的图像。当我们遇到适合 PNG 的场景时，也会优先选择更为小巧的 PNG-8 。</p><p>亦或者需要处理有透明度或线条明显的图片时，也会采用 PNG 。如网站主 logo：<br><img src="/images/post/6355096a53689.png"></img></p><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>严格来说应该是一种开放标准的矢量图形语言。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>    <li>可缩放,可支持无限放大</li>    <li>可编程</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>    <li>不是所有的浏览器都支持 SVG，IE8 和早期版本都需要一个插件。</li>    <li>复杂的图片会降低渲染速度(只支持小图)。</li></ul><img src="/images/post/6355096e70295.png"></img><h4 id="业务场景-2"><a href="#业务场景-2" class="headerlink" title="业务场景"></a>业务场景</h4><p>SVG 是文本文件，我们既可以像写代码一样定义 SVG ，把它写在 HTML 里、成为 DOM 的一部分。用的比较多的就是 iconfont。我们可以通过设置模块的fill属性轻松适配图标的换肤功能，并通过font-size调节其大小。</p><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>一种基于 64 个可打印字符来表示二进制数据的方法。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>    <li>减少网络请求</li>    <li>对于动态实时生成的图片无需将图片存储在服务器占用服务器资源</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>    <li>只适于小图。</li>    <li>若需要频繁替换的图片需要整个代码替换，可维护性低。</li></ul><h4 id="业务场景-3"><a href="#业务场景-3" class="headerlink" title="业务场景"></a>业务场景</h4><p>Base64 和雪碧图一样，是作为小图标解决方案而存在的。<br><img src="/images/post/63550972c22e4.png"></img></p><div class="note info flat"><p>“ Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS ，从而减少 HTTP 请求的次数。”</p></div><p>在 Elements 中搜索 “base64” 关键字，你会发现 Base64 也有很多使用的地方。而且它对应的图片占用内存较小。</p><p>既然 Base64 这么棒，我们把所有图片都用Base64 好了嘛。<br><img src="/images/post/6355097710675.png"></img><br>Base64 编码后，图片大小会膨胀为原文件的 4&#x2F;3（Base64 编码原理）。如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请求，也无法弥补这庞大的体积带来的性能开销。也就是说我们牺牲的 渲染性能 大于 资源请求性能，这样做不太值得。</p><p>我们可以看到，大多数用 Base64 编码的图片都是小图。<br><img src="/images/post/6355097a2861a.png"></img></p><h3 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h3><p>一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>    <li>支持有损无损</li>    <li>占用体积小</li>    <li>可支持透明</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>    <li>兼容性不好</li></ul><img src="/images/post/63551310ab344.png"></img><h4 id="业务场景-4"><a href="#业务场景-4" class="headerlink" title="业务场景"></a>业务场景</h4><p>同 JPEG&#x2F;JPG 。因为目前兼容性不好，一般搭配 JPEG&#x2F;JPG 一起使用。<br><img src="/images/post/635513172207c.png"></img></p><h3 id="OSS-搭配-CDN"><a href="#OSS-搭配-CDN" class="headerlink" title="OSS 搭配 CDN"></a>OSS 搭配 CDN</h3><p>我们原始的方式是将图片等资源一起放入项目中打包上线。<br><img src="/images/post/6355131d0ce12.png"></img><br>这样做的缺点在于打包出来的包大不说，用户请求资源的速度也会受到限制。比如我们的服务器在华南，华北的用户请求就会稍慢。当遇到并发量大的情况时，从部署服务器请求接口与资源这无外乎给我们的服务器提供了多余的压力。当我们临时想替换一张图片时，也需要重新打包并发布上线，非常麻烦。<br><img src="/images/post/6355131fcb0e2.png"></img><br>当我们将图片进行 OSS 放置并 CDN 加速后，这个问题就得到了很好的解决。不同地区的用户可以访问就近服务器，重复的请求也会产生缓存，避免 OSS 流量的浪费。</p><h3 id="图片的懒加载"><a href="#图片的懒加载" class="headerlink" title="图片的懒加载"></a>图片的懒加载</h3><p>在遇到首屏数据过多加载缓慢的情况下，我们就需要考虑懒加载了。当用户滚动到预览位置时，在进行图片数据的请求。期间用骨架屏或缩略图代替。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取图片列表，即 img 标签列表</span></span><br><span class="line">    <span class="keyword">var</span> imgs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="comment">// 获取到浏览器顶部的距离</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getTop</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> e.<span class="property">offsetTop</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 懒加载实现</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">lazyload</span>(<span class="params">imgs</span>) &#123;</span><br><span class="line">        <span class="comment">// 可视区域高度</span></span><br><span class="line">        <span class="keyword">var</span> h = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">        <span class="comment">// 滚动区域高度</span></span><br><span class="line">        <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//图片距离顶部的距离大于可视区域和滚动区域之和时懒加载</span></span><br><span class="line">            <span class="keyword">if</span> ((h + s) &gt; <span class="title function_">getTop</span>(imgs[i])) &#123;</span><br><span class="line">                <span class="comment">// 真实情况是页面开始有2秒空白，所以使用 setTimeout 定时 2s</span></span><br><span class="line">                (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                        <span class="comment">// 不加立即执行函数i会等于9</span></span><br><span class="line">                        <span class="comment">// 隐形加载图片或其他资源，</span></span><br><span class="line">                        <span class="comment">// 创建一个临时图片，这个图片在内存中不会到页面上去。实现隐形加载</span></span><br><span class="line">                        <span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">                        temp.<span class="property">src</span> = imgs[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-src&#x27;</span>);<span class="comment">//只会请求一次</span></span><br><span class="line">                        <span class="comment">// onload 判断图片加载完毕，真是图片加载完毕，再赋值给 dom 节点</span></span><br><span class="line">                        temp.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                            <span class="comment">// 获取自定义属性 data-src，用真图片替换假图片</span></span><br><span class="line">                            imgs[i].<span class="property">src</span> = imgs[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-src&#x27;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">2000</span>)</span><br><span class="line">                &#125;)(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">lazyload</span>(imgs);</span><br><span class="line">    <span class="comment">// 滚屏函数</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onscroll</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">lazyload</span>(imgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是单点登录以及实现？</title>
      <link href="/2024/09/18/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2024/09/18/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是单点登录-如何实现？"><a href="#什么是单点登录-如何实现？" class="headerlink" title="什么是单点登录?如何实现？"></a>什么是单点登录?如何实现？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单点登录(Single Sign On)，简称为 SSO，是目前比较流行的企业业务整合的解决方案之-SSO的定义</span><br><span class="line">是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统SSO</span><br><span class="line">一般都需要一个独立的认证中心(passport)，子系统的登录均得通过 passport ，</span><br><span class="line">子系统本身将不参与登录操作。</span><br><span class="line">    当一个系统成功登录以后，passport 将会颁发一个令牌给各个子系统，</span><br><span class="line">    子系统可以拿着令牌会获取各自的受保护资源，</span><br><span class="line">    为了减少频繁认证，各个子系统在被 passport 授权以后，会建立一个局部会话，</span><br><span class="line">    在一定时间内可以无需再次向 passport发起认证</span><br></pre></td></tr></table></figure><h3 id="同域名下的单点登录"><a href="#同域名下的单点登录" class="headerlink" title="同域名下的单点登录"></a>同域名下的单点登录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cookie 的 domain 属性设置为当前域的父域，并且父域的 cookie 会被子域所共享。 </span><br><span class="line">path 属性默认为 web 应用的上下文路径</span><br><span class="line">利用 Cookie 的这个特点，没错，我们只需要将Cookie 的 domain 属性设置为父域的域名(主域名)，</span><br><span class="line">同时将Cookie的path属性设置为根路径，将SessionID(或Token )保存到父域中。</span><br><span class="line">这样所有的子域应用就都可以访问到这个Cookie不过这要求应用系统的域名需建立在一个共同的主域名之下，</span><br><span class="line">如 tieba.baidu.com 和 map.baidu.com ，它们都建立在 baidu.com 这个主域名之下，那么它们就可以通过这种方式来实现单点登录</span><br></pre></td></tr></table></figure><h3 id="不同域名下的单点登录-一"><a href="#不同域名下的单点登录-一" class="headerlink" title="不同域名下的单点登录(一)"></a>不同域名下的单点登录(一)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">如果是不同域的情况下，Cookie 是不共享的，这里我们可以部署一个认证中心，</span><br><span class="line">用于专门处理登录请求的独立的 Web 服务</span><br><span class="line">用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，</span><br><span class="line">并将token写入Co0kie(注意这个Cookie 是认证中心的，应用系统是访问不到的)</span><br><span class="line">应用系统检查当前请求有没有Token，如果没有，说明用户在当前系统中尚未登录，</span><br><span class="line">那么就将页面跳转至认证中心</span><br><span class="line">由于这个操作会将认证中心的Cookie 自动带过去，</span><br><span class="line">因此，认证中心能够根据Cookie 知道用户是否已经登录过了</span><br><span class="line">如果认证中心发现用户尚未登录，则返回登录页面，</span><br><span class="line">等待用户登录如果发现用户已经登录过了，就不会让用户再次登录了，</span><br><span class="line">而是会跳转回目标URL，并在跳转前生成一个Token，</span><br><span class="line">拼接在目标 URL的后面，回传给目标应用系统</span><br><span class="line">应用系统拿到 Token 之后，还需要向认证中心确认下Token 的合法性，</span><br><span class="line">防止用户伪造。确认无误后，应用系统记录用户的登录状态，</span><br><span class="line">并将Token写入Cookie然后给本次访问放行。</span><br><span class="line">(注意这个 Cookie 是当前应用系统的)当用户再次访问当前应用系统时，</span><br><span class="line">就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，</span><br><span class="line">于是就不会有认证中心什么事了此种实现方式相对复杂，</span><br><span class="line">支持跨域，扩展性好，是单点登录的标准做法</span><br></pre></td></tr></table></figure><h3 id="不同域名下的单点登录-二"><a href="#不同域名下的单点登录-二" class="headerlink" title="不同域名下的单点登录(二)"></a>不同域名下的单点登录(二)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">可以选择将 SessionID(或 Token )保存到浏览器的 LocalStorage 中，</span><br><span class="line">让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端</span><br><span class="line">后端需要做的仅仅是在用户登录成功后，</span><br><span class="line">将SessionID或Token这些都是由前端来控制的，</span><br><span class="line">放在响应体中传递给前端</span><br><span class="line">单点登录完全可以在前端实现。</span><br><span class="line">前端拿到SessionID(或Token)后，</span><br><span class="line">除了将它写入自己的LocalStorage 中之外，</span><br><span class="line">还可以通过特殊手段将它写入多个其他域下的LocalStorage中</span><br><span class="line">前端通过 iframe+postMessage()方式，</span><br><span class="line">将同一份 Token 写入到了多个域下的 LocalStorage 中，</span><br><span class="line">前端每次在向后端发送请求之前，</span><br><span class="line">都会主动从LocalStorage 中读取 Token 并在请求中携带，</span><br><span class="line">这样就实现了同一份 Token 被多个域所共享</span><br><span class="line">此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么实现虚拟列表？</title>
      <link href="/2024/09/15/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%EF%BC%9F/"/>
      <url>/2024/09/15/%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟列表的使用场景"><a href="#虚拟列表的使用场景" class="headerlink" title="虚拟列表的使用场景"></a>虚拟列表的使用场景</h2><p>如果我想要在网页中放大量的列表项，纯渲染的话，对于浏览器性能将会是个极大的挑战，会造成滚动卡顿，整体体验非常不好，主要有以下问题：<br><ui></p><li>页面等待时间极长，用户体验差</li><li>CPU 计算能力不够，滑动会卡顿</li><li>GPU 渲染能力不够，页面会跳屏</li><li>RAM 内存容量不够，浏览器崩溃</li></ui><h3 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h3><p>对于长列表渲染，传统的方法是使用懒加载的方式，下拉到底部获取新的内容加载进来，其实就相当于是在垂直方向上的分页叠加功能，但随着加载数据越来越多，浏览器的回流和重绘的开销将会越来越大，整个滑动也会造成卡顿，这个时候我们就可以考虑使用虚拟列表来解决问题。</p><h3 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h3><p>其核心思想就是在处理用户滚动时，只改变列表在可视区域的渲染部分，具体步骤为：</p><p>先计算可见区域起始数据的索引值startIndex和当前可见区域结束数据的索引值endIndex，假如元素的高度是固定的，那么startIndex的算法很简单，即startIndex &#x3D; Math.floor(scrollTop&#x2F;itemHeight)，endIndex &#x3D; startIndex + (clientHeight&#x2F;itemHeight) - 1，再根据startIndex和endIndex取相应范围的数据，渲染到可视区域，然后再计算startOffset（上滚动空白区域）和endOffset（下滚动空白区域），这两个偏移量的作用就是来撑开容器元素的内容，从而起到缓冲的作用，使得滚动条保持平滑滚动，并使滚动条处于一个正确的位置</p><p>上述的操作可以总结成五步：<br><ui></p><li>不把长列表数据一次性全部直接渲染在页面上</li><li>截取长列表一部分数据用来填充可视区域</li><li>长列表数据不可视部分使用空白占位填充（下图中的startOffset和endOffset区域）</li><li>监听滚动事件根据滚动位置动态改变可视列表</li><li>监听滚动事件根据滚动位置动态改变空白填充</li></ui><img src="/images/post/63de2ce894ab0.jpg"></img><h2 id="定高虚拟列表实现步骤"><a href="#定高虚拟列表实现步骤" class="headerlink" title="定高虚拟列表实现步骤"></a>定高虚拟列表实现步骤</h2><p>实现的效果应该是：不论怎么滚动，我们改变的只是滚动条的高度和可视区的元素内容，并没有增加任何多余的元素，下面来看看要怎么实现吧！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 虚拟列表DOM结构</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span></span><br><span class="line">  // 监听滚动事件的盒子，该高度继承了父元素的高度</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;scroll-box&#x27;</span> <span class="attr">ref</span>=<span class="string">&#123;containerRef&#125;</span> <span class="attr">onScroll</span>=<span class="string">&#123;boxScroll&#125;</span>&gt;</span></span><br><span class="line">    // 该盒子的高度一定会超过父元素，要不实现不了滚动的效果，而且还要动态的改变它的padding值用于控制滚动条的状态</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;topBlankFill.current&#125;</span>&gt;</span></span><br><span class="line">      &#123;</span><br><span class="line">      showList.map(item =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;item&#x27;</span> <span class="attr">key</span>=<span class="string">&#123;item.commentId</span> || (<span class="attr">Math.random</span>() + <span class="attr">item.comments</span>)&#125;&gt;</span>&#123;item.content&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="计算容器最大容积数量"><a href="#计算容器最大容积数量" class="headerlink" title="计算容器最大容积数量"></a>计算容器最大容积数量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 滚动容器高度改变后执行的函数</span></span><br><span class="line"><span class="keyword">const</span> changeHeight = <span class="title function_">useCallback</span>(<span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 容器高度，通过操作dom元素获取高度是因为它不一定是个定值</span></span><br><span class="line">  curContainerHeight.<span class="property">current</span> = containerRef.<span class="property">current</span>.<span class="property">offsetHeight</span></span><br><span class="line">  <span class="comment">// 列表最大数量，考虑到列表中顶部和底部可能都会出现没有展现完的item</span></span><br><span class="line">  curViewNum.<span class="property">current</span> = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(curContainerHeight.<span class="property">current</span> / itemHeight) + <span class="number">1</span></span><br><span class="line">&#125;, <span class="number">500</span>), [])</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 组件第一次挂载需要初始化容器的高度以及最大容纳值</span></span><br><span class="line">  <span class="title function_">changeHeight</span>()</span><br><span class="line">  <span class="comment">// 因为我们的可视窗口和浏览器大小有关系，所以我们需要监听浏览器大小的变化</span></span><br><span class="line">  <span class="comment">// 当浏览器大小改变之后需要重新执行changeHeight函数计算当前可视窗口对应的最大容纳量是多少</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, changeHeight)</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, changeHeight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [changeHeight])</span><br></pre></td></tr></table></figure><h3 id="监听滚动事件动态截取数据-设置上下滚动缓冲消除快速滚动白屏"><a href="#监听滚动事件动态截取数据-设置上下滚动缓冲消除快速滚动白屏" class="headerlink" title="监听滚动事件动态截取数据&amp;&amp;设置上下滚动缓冲消除快速滚动白屏"></a>监听滚动事件动态截取数据&amp;&amp;设置上下滚动缓冲消除快速滚动白屏</h3><p>这是虚拟列表的核心之处，不将所有我们请求到的元素渲染出来，而是只渲染我们能够看到的元素，大大减少了容器内的dom节点数量。</p><p>不过有个隐藏的问题我们需要考虑到，当用户滑动过快的时候，很多用户的设备性能并不是很好，很容易出现屏幕已经滚动过去了，但是列表项还没有及时加载出来的情况，这个时候用户就会看到短暂的白屏，对用户的体验非常不好。所以我们需要设置一段缓冲区域，让用户过快的滚动之后还能看到我们提前渲染好的数据，等到缓冲数据滚动完了，我们新的数据也渲染到页面中去了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const scrollHandle = () =&gt; &#123;</span><br><span class="line">  // 注意这个对应的是可视区第一个元素的索引值，而不是第多少个元素</span><br><span class="line">  let startIndex = Math.floor(containerRef.current.scrollTop / itemHeight) // itemHeight是列表每一项的高度</span><br><span class="line">  // 优化：如果是用户滚动触发的，而且两次startIndex的值都一样，那么就没有必要执行下面的逻辑</span><br><span class="line">  if (!isNeedLoad &amp;&amp; lastStartIndex.current === startIndex) return</span><br><span class="line">  isNeedLoad.current = false</span><br><span class="line">  lastStartIndex.current = startIndex</span><br><span class="line">  const containerMaxSize = curViewNum.current</span><br><span class="line">  /**</span><br><span class="line">   * 解决滑动过快出现的白屏问题：注意endIndex要在startIndex人为改变之前就计算好</span><br><span class="line">   * 因为我们实际上需要三板的数据用于兼容低性能的设备，用做上下滚动的缓冲区域，避免滑动的时候出现白屏</span><br><span class="line">   * 现在的startIndex是可视区的第一个元素索引，再加上2倍可视区元素量，刚好在下方就会多出一板来当做缓冲区</span><br><span class="line">   */</span><br><span class="line">  // 此处的endIndex是为了在可视区域的下方多出一板数据</span><br><span class="line">  let endIndex = startIndex + 2 * containerMaxSize - 1</span><br><span class="line">  // 接近滚动到屏幕底部的时候，就可以请求发送数据了，这个时候触底的并不是可视区的最后一个元素，而是多出那一版的最后一个元素触底了</span><br><span class="line">  const currLen = dataListRef.current.length</span><br><span class="line">  if (endIndex &gt; currLen - 1) &#123;</span><br><span class="line">    // 更新请求参数，发送请求获取新的数据(但是要保证当前不在请求过程中，否则就会重复请求相同的数据)</span><br><span class="line">    !isRequestRef.current &amp;&amp; setOptions(state =&gt; (&#123; offset: state.offset + 1 &#125;))</span><br><span class="line">    // 如果已经滚动到了底部，那么就设置endIndex为最后一个元素索引即可</span><br><span class="line">    endIndex = currLen - 1</span><br><span class="line">  &#125;</span><br><span class="line">  // 此处的endIndex是为了在可视区域的上方多出一板数据</span><br><span class="line">  // 这里人为的调整startIndex的值，目的就是为了能够在可视区域上方多出一板来当做缓冲区</span><br><span class="line">  if (startIndex &lt;= containerMaxSize) &#123; // containerMaxSize是我们之前计算出来的容器容纳量</span><br><span class="line">    startIndex = 0</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    startIndex = startIndex - containerMaxSize</span><br><span class="line">  &#125;</span><br><span class="line">  // 使用slice方法截取数据，但是要记住第二个参数对应的索引元素不会被删除，最多只能删除到它的前一个，所以我们这里的endIndex需要加一</span><br><span class="line">  setShowList(dataListRef.current.slice(startIndex, endIndex + 1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态设置上下空白占位"><a href="#动态设置上下空白占位" class="headerlink" title="动态设置上下空白占位"></a>动态设置上下空白占位</h3><p>这是虚拟列表的灵魂所在，本质上我们数据量是很少的，一般来说只有几条到十几条数据，如果不对列表做一些附加的操作，连生成滚动条都有点困难，更别说让用户自由操控滚动条滚动了。</p><p>我们必须要用某种方法将内容区域撑起来，这样才会出现比较合适的滚动条。我这里采取的方法就是设置paddingTop和paddingBottom的值来动态的撑开内容区域。</p><p>为什么要动态的改变呢？举个例子，我们向下滑动的时候会更换页面中要展示的数据列表，如果不改变原先的空白填充区域，那么随着滚动条的滚动，原先展示在可视区的第一条数据就会向上移动，虽然我们更新的数据是正确的，但并没有将它们展示在合适的位置。完美的方案是是不仅要展示正确的数据，而且还要改变空白填充区域高度，使得数据能够正确的展示在浏览器视口当中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码要放在更新列表数据之前，也是在滚动事件boxScroll当中</span></span><br><span class="line"><span class="comment">// 改变空白填充区域的样式，否则就会出现可视区域的元素与滚动条不匹配的情况，实现不了平滑滚动的效果</span></span><br><span class="line">topBlankFill.<span class="property">current</span> = &#123;</span><br><span class="line">  <span class="comment">// 起始索引就是缓冲区第一个元素的索引，索引为多少就代表前面有多少个元素</span></span><br><span class="line">  <span class="attr">paddingTop</span>: <span class="string">`<span class="subst">$&#123;startIndex * itemHeight&#125;</span>px`</span>,</span><br><span class="line">  <span class="comment">// endIndex是缓冲区的最后一个元素，可能不在可视区内；用dataListRef数组最后一个元素的索引与endIndex相减就可以得到还没有渲染元素的数目</span></span><br><span class="line">  <span class="attr">paddingBottom</span>: <span class="string">`<span class="subst">$&#123;(dataListRef.current.length - <span class="number">1</span> - endIndex) * itemHeight&#125;</span>px`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉置底自动请求和加载数据"><a href="#下拉置底自动请求和加载数据" class="headerlink" title="下拉置底自动请求和加载数据"></a>下拉置底自动请求和加载数据</h3><p>在真实的开发场景中，我们不会一次性请求1w、10w条数据过来，这样请求时间那么长，用户早就把页面关掉了，还优化个屁啊哈哈！</p><p>所以真实开发中，我们还是要结合原来的懒加载方式，等到下拉触底的时候去加载新的数据进来，放置到缓存数据当中，然后我们再根据滚动事件决定具体渲染哪一部分的数据到页面上去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 组件刚挂载以及下拉触底的时候请求更多数据</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  (async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 表明当前正处于请求过程中</span><br><span class="line">      isRequestRef.current = true</span><br><span class="line">      const &#123; offset &#125; = options</span><br><span class="line">      let limit = 20</span><br><span class="line">      if (offset === 1) limit = 40</span><br><span class="line">      const &#123; data: &#123; comments, more &#125; &#125; = await axios(&#123;</span><br><span class="line">        url: `http://localhost:3000/comment/music?id=$&#123;186015 - offset&#125;&amp;limit=$&#123;limit&#125;&amp;offset=1`</span><br><span class="line">      &#125;)</span><br><span class="line">      isNeedLoad.current = more</span><br><span class="line">      // 将新请求到的数据添加到存储列表数据的变量当中</span><br><span class="line">      dataListRef.current = [...dataListRef.current, ...comments]</span><br><span class="line">      // 必选要在boxScroll之前将isRequestRef设为false，因为boxScroll函数内部会用到这个变量</span><br><span class="line">      isRequestRef.current = false</span><br><span class="line">      // 请求完最新数据的时候需要重新触发一下boxScroll函数，因为容器内的数据、空白填充区域可能需要变化</span><br><span class="line">      boxScroll()</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      isRequestRef.current = false</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">  // 在boxScroll函数里面，一旦发生了触底操作就会去改变optiosn的值</span><br><span class="line">&#125;, [options])</span><br></pre></td></tr></table></figure><h4 id="滚动事件请求动画帧进行节流优化"><a href="#滚动事件请求动画帧进行节流优化" class="headerlink" title="滚动事件请求动画帧进行节流优化"></a>滚动事件请求动画帧进行节流优化</h4><p>虚拟列表很依赖于滚动事件，考虑到用户可能会滑动很快，我们在用节流优化的时候事件必须要设置的够短，否则还是会出现白屏现象。</p><p>这里我没有用传统的节流函数，而是用到了请求动画帧帮助我们进行节流，这里就不做具体介绍了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用请求动画帧做了一个节流优化</span></span><br><span class="line"><span class="keyword">let</span> then = <span class="title function_">useRef</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">boxScroll</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这里的等待时间不宜设置过长，不然会出现滑动到空白占位区域的情况</span></span><br><span class="line"><span class="comment">   * 因为间隔时间过长的话，太久没有触发滚动更新事件，下滑就会到padding-bottom的空白区域</span></span><br><span class="line"><span class="comment">   * 电脑屏幕的刷新频率一般是60HZ，渲染的间隔时间为16.6ms，我们的时间间隔最好小于两次渲染间隔16.6*2=33.2ms，一般情况下30ms左右，</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (now - then.<span class="property">current</span> &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    then.<span class="property">current</span> = now</span><br><span class="line">    <span class="comment">// 重复调用scrollHandle函数，让浏览器在下一次重绘之前执行函数，可以确保不会出现丢帧现象</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(scrollHandle)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，填充空白区域、模拟滚动条还有其它的办法，比如根据总数据量让一个盒子撑开父盒子用于生成滚动条，根据startIndex计算出可视区域距离顶部的距离并调节内容区域元素的transform属性，即startOffset &#x3D; scrollTop - (scrollTop % this.itemSize)，让内容区域一直暴露在可视区域内</p><p>目前为止，我们已经实现了固定高度的列表项用虚拟列表来展示的功能！接下里我们将会介绍关于不定高（其高度由内容进行撑开）的列表项如何用虚拟列表进行优化</p><h2 id="不定高虚拟列表实现步骤"><a href="#不定高虚拟列表实现步骤" class="headerlink" title="不定高虚拟列表实现步骤"></a>不定高虚拟列表实现步骤</h2><p>在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的就能获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本、图片之类的可变内容，会导致列表项的高度并不相同。</p><p>我们在列表渲染之前，确实没有办法知道每一项的高度，但是又必须要渲染出来，那怎么办呢？</p><p>这里有一个解决方法，就是先给没有渲染出来的列表项设置一个预估高度，等到这些数据渲染成真实dom元素了之后，再获取到他们的真实高度去更新原来设置的预估高度，下面我们来看看跟定高列表有什么不同，具体要怎么实现吧！</p><h3 id="请求到新数据对数据进行初始化（设置预估高度）"><a href="#请求到新数据对数据进行初始化（设置预估高度）" class="headerlink" title="请求到新数据对数据进行初始化（设置预估高度）"></a>请求到新数据对数据进行初始化（设置预估高度）</h3><p>预估高度的设置其实是有技巧的，列表项预估高度设置的越大，展现出来的数据就会越少，所以当预估高度比实际高度大很多的时候，很容易出现可视区域数据量太少而引起的可视区域出现部分空白。为了避免这种情况，我们的预估高度应该设置为列表项产生的最小值，这样尽管可能会多渲染出几条数据，但能保证首次呈现给用户的画面中没有空白</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 请求更多的数据</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  (async () =&gt; &#123;</span><br><span class="line">    // 只有当前不在请求状态的时候才可以发送新的请求</span><br><span class="line">    if (!isRequestRef.current) &#123;</span><br><span class="line">      console.log(&#x27;发送请求了&#x27;);</span><br><span class="line">      try &#123;</span><br><span class="line">        isRequestRef.current = true</span><br><span class="line">        const &#123; offset &#125; = options</span><br><span class="line">        let limit = 20</span><br><span class="line">        if (offset === 1) limit = 40</span><br><span class="line">        const &#123; data: &#123; comments, more &#125; &#125; = await axios(&#123;</span><br><span class="line">          url: `http://localhost:3000/comment/music?id=$&#123;186015 - offset&#125;&amp;limit=$&#123;limit&#125;&amp;offset=1`</span><br><span class="line">        &#125;)</span><br><span class="line">        isNeedLoad.current = more</span><br><span class="line">        // 获取缓存中最后一个数据的索引值，如果没有，则返回-1</span><br><span class="line">        const lastIndex = dataListRef.current.length ? dataListRef.current[dataListRef.current.length - 1].index : -1</span><br><span class="line">        // 先将请求到的数据添加到缓存数组中去</span><br><span class="line">        dataListRef.current = [...dataListRef.current, ...comments]</span><br><span class="line">        const dataList = dataListRef.current</span><br><span class="line">        // 将刚刚请求到的新数据做一下处理，为他们添加上对应的索引值、预估高度、以及元素首尾距离容器顶部的距离</span><br><span class="line">        for (let i = lastIndex + 1, len = dataListRef.current.length; i &lt; len; i++) &#123;</span><br><span class="line">          dataList[i].index = i</span><br><span class="line">          // 预估高度是列表项对应的最小高度</span><br><span class="line">          dataList[i].height = 63</span><br><span class="line">          // 每一个列表项头部距离容器顶部的距离等于上一个元素尾部距离容器顶部的距离</span><br><span class="line">          dataList[i].top = dataList[i - 1]?.bottom || 0</span><br><span class="line">          // 每一个列表项尾部距离容器顶部的距离等于上一个元素头部距离容器顶部的距离加上自身列表项的高度</span><br><span class="line">          dataList[i].bottom = dataList[i].top + dataList[i].height</span><br><span class="line">        &#125;</span><br><span class="line">        isRequestRef.current = false</span><br><span class="line">        boxScroll()</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        isRequestRef.current = false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">  // eslint-disable-next-line</span><br><span class="line">&#125;, [options])</span><br></pre></td></tr></table></figure><h3 id="每次列表更新之后将列表项真实高度更新缓存中的预估高度"><a href="#每次列表更新之后将列表项真实高度更新缓存中的预估高度" class="headerlink" title="每次列表更新之后将列表项真实高度更新缓存中的预估高度"></a>每次列表更新之后将列表项真实高度更新缓存中的预估高度</h3><p>在React函数式组件中，useEffect只要不传第二个参数，就可以实现类组件componentDidUpdate生命周期函数的作用，只要我们重新渲染一次列表组件，就会重新计算一下当前列表每一项中的真实高度并更新到缓存中去，当下次我们再用到缓存中的这些数据时，使用的就是真实高度了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次组件重新渲染即用户滚动更改了数据之后需要将列表中我们还不知道的列表项高度更新到我们的缓存数据中去，以便下一次更新的时候能够正常渲染</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="keyword">const</span> doms = containerRef.<span class="property">current</span>.<span class="property">children</span>[<span class="number">0</span>].<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> len = doms.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 因为一开始我们没有请求数据，所以即使组件渲染完了，但是没有列表项，此时不需要执行后续操作</span></span><br><span class="line">  <span class="keyword">if</span> (len) &#123;</span><br><span class="line">    <span class="comment">// 遍历所有的列表结点，根据结点的真实高度去更改缓存中的高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> realHeight = doms[i].<span class="property">offsetHeight</span></span><br><span class="line">      <span class="keyword">const</span> originHeight = showList[i].<span class="property">height</span></span><br><span class="line">      <span class="keyword">const</span> dValue = realHeight - originHeight</span><br><span class="line">      <span class="comment">// 如果列表项的真实高度就是缓存中的高度，则不需要进行更新</span></span><br><span class="line">      <span class="keyword">if</span> (dValue) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = showList[i].<span class="property">index</span></span><br><span class="line">        <span class="keyword">const</span> allData = dataListRef.<span class="property">current</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 如果列表项的真实高度不是缓存中的高度，那么不仅要更新缓存中这一项的bottom和height属性</span></span><br><span class="line"><span class="comment">           * 在该列表项后续的所有列表项的top、bottom都会受到它的影响，所以我们又需要一层for循环进行更改缓存中后续的值</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">        allData[index].<span class="property">bottom</span> += dValue</span><br><span class="line">        allData[index].<span class="property">height</span> = realHeight</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 注意：这里更改的一定要是缓存数组中对应位置后续的所有值，如果只改变的是showList值的话</span></span><br><span class="line"><span class="comment">           * 会造成dataList间断性的bottom和下一个top不连续，因为startIndex、endIndex以及空白填充区域都是依据top和bottom值来进行计算的</span></span><br><span class="line"><span class="comment">           * 所以会导致最后计算的结果出错，滑动得来的startIndex变化幅度大且滚动条不稳定，出现明显抖动问题</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = index + <span class="number">1</span>, len = allData.<span class="property">length</span>; j &lt; len; j++) &#123;</span><br><span class="line">          allData[j].<span class="property">top</span> = allData[j - <span class="number">1</span>].<span class="property">bottom</span></span><br><span class="line">          allData[j].<span class="property">bottom</span> += dValue</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="得到可视区域的起始和结束元素索引-设置上下滚动缓冲区域消除快速滚动白屏"><a href="#得到可视区域的起始和结束元素索引-设置上下滚动缓冲区域消除快速滚动白屏" class="headerlink" title="得到可视区域的起始和结束元素索引&amp;&amp;设置上下滚动缓冲区域消除快速滚动白屏"></a>得到可视区域的起始和结束元素索引&amp;&amp;设置上下滚动缓冲区域消除快速滚动白屏</h3><p>列表项的bottom属性代表的就是该元素尾部到容器顶部的距离，不难发现，可视区的第一个元素的bottom是第一个大于滚动高度的；可视区最后一个元素的bottom是第一个大于（滚动高度+可视高度）的。我们可以利用这条规则遍历缓存数组找到对应的startIndex和endIndex</p><p>由于我们的缓存数据，本身就是有顺序的，所以获取开始索引的方法可以考虑通过二分查找的方式来降低检索次数，减少时间复杂度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到要渲染数据的起始索引和结束索引</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getIndex</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 设置缓冲区域的数据量</span></span><br><span class="line">  <span class="keyword">const</span> aboveCount = <span class="number">5</span></span><br><span class="line">  <span class="keyword">const</span> belowCount = <span class="number">5</span></span><br><span class="line">  <span class="comment">// 结果数组，里面包含了起始索引和结束索引</span></span><br><span class="line">  <span class="keyword">const</span> resObj = &#123;</span><br><span class="line">    <span class="attr">startIndex</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">endIndex</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> scrollTop = containerRef.<span class="property">current</span>.<span class="property">scrollTop</span></span><br><span class="line">  <span class="keyword">const</span> dataList = dataListRef.<span class="property">current</span></span><br><span class="line">  <span class="keyword">const</span> len = dataList.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 设置上层缓冲区，如果索引值大于缓冲区域，那么就需要减小startIndex的值用于设置顶层缓冲区</span></span><br><span class="line">  <span class="keyword">const</span> startIndex = <span class="title function_">binarySearch</span>(scrollTop)</span><br><span class="line">  <span class="keyword">if</span> (startIndex &lt;= aboveCount) &#123;</span><br><span class="line">    resObj.<span class="property">startIndex</span> = <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resObj.<span class="property">startIndex</span> = startIndex - aboveCount</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓冲数据中第一个bottom大于滚动高度加上可视区域高度的元素就是可视区域最后一个元素</span></span><br><span class="line"><span class="comment">     * 如果没有找到的话就说明当前滚动的幅度过大，缓存中没有数据的bottom大于我们的目标值，所以搜索不到对应的索引，我们只能拿缓存数据中的最后一个元素补充上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">const</span> endIndex = <span class="title function_">binarySearch</span>(scrollTop + curContainerHeight.<span class="property">current</span>) || len - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 增大endIndex的索引值用于为滚动区域下方设置一段缓冲区，避免快速滚动所导致的白屏问题</span></span><br><span class="line">  resObj.<span class="property">endIndex</span> = endIndex + belowCount</span><br><span class="line">  <span class="keyword">return</span> resObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于我们的缓存数据，本身就是有顺序的，所以获取开始索引的方法可以考虑通过二分查找的方式来降低检索次数：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">binarySearch</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> list = dataListRef.<span class="property">current</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> end = list.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> tempIndex = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">let</span> midIndex = <span class="built_in">parseInt</span>((start + end) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> midValue = list[midIndex].<span class="property">bottom</span>;</span><br><span class="line">    <span class="keyword">if</span> (midValue === value) &#123;</span><br><span class="line">      <span class="comment">// 说明当前滚动区域加上可视区域刚好是一个结点的边界，那么我们可以以其下一个结点作为末尾元素</span></span><br><span class="line">      <span class="keyword">return</span> midIndex + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midValue &lt; value) &#123;</span><br><span class="line">      <span class="comment">// 由于当前值与目标值还有一定的差距，所以我们需要增加start值以让下次中点的落点更靠后</span></span><br><span class="line">      start = midIndex + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midValue &gt; value) &#123;</span><br><span class="line">      <span class="comment">// 因为我们的目的并不是找到第一个满足条件的值，而是要找到满足条件的最小索引值</span></span><br><span class="line">      <span class="keyword">if</span> (tempIndex === <span class="literal">null</span> || tempIndex &gt; midIndex) &#123;</span><br><span class="line">        tempIndex = midIndex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 由于我们要继续找更小的索引，所以需要让end-1以缩小范围，让下次中点的落点更靠前</span></span><br><span class="line">      end--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tempIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听滚动事件动态截取数据-动态设置上下空白占位"><a href="#监听滚动事件动态截取数据-动态设置上下空白占位" class="headerlink" title="监听滚动事件动态截取数据&amp;&amp;动态设置上下空白占位"></a>监听滚动事件动态截取数据&amp;&amp;动态设置上下空白占位</h3><p>动态截取数据的操作和定高的虚拟列表几乎一样，区别比较大的地方就在padding值的计算方式上。在定高的列表中，我们可以根据起始索引值和结尾索引值直接计算出空白填充区域的高度。</p><p>其实在不定高的列表中，计算方式更加简单，因为startIndex对应元素的top值就是我们需要填充的上空白区域，下空白区域也可以根据整个列表的高度（最后一个元素的bottom值）和endIndex对应元素的bottom值之差得出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">scrollHandle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取当前要渲染元素的起始索引和结束索引值</span></span><br><span class="line">  <span class="keyword">let</span> &#123; startIndex, endIndex &#125; = <span class="title function_">getIndex</span>()</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是用户滚动触发的，而且两次startIndex的值都一样，那么就没有必要执行下面的逻辑，</span></span><br><span class="line"><span class="comment">     * 除非是用户重新请求了之后需要默认执行一次该函数，这是一种特殊情况，就是startIndex没变，但需要执行后续的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">if</span> (!isNeedLoad &amp;&amp; lastStartIndex.<span class="property">current</span> === startIndex) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 渲染完一次之后就需要初始化isNeedLoad</span></span><br><span class="line">  isNeedLoad.<span class="property">current</span> = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 用于实时监控lastStartIndex的值</span></span><br><span class="line">  lastStartIndex.<span class="property">current</span> = startIndex</span><br><span class="line">  <span class="comment">// 下层缓冲区域最后的元素接触到屏幕底部的时候，就可以请求发送数据了</span></span><br><span class="line">  <span class="keyword">const</span> currLen = dataListRef.<span class="property">current</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (endIndex &gt;= currLen - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前不在请求状态下时才可以改变请求参数发送获取更多数据的请求</span></span><br><span class="line">    !isRequestRef.<span class="property">current</span> &amp;&amp; <span class="title function_">setOptions</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">offset</span>: state.<span class="property">offset</span> + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="comment">// 注意endIndex不可以大于缓存中最后一个元素的索引值</span></span><br><span class="line">    endIndex = currLen - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 空白填充区域的样式</span></span><br><span class="line">  topBlankFill.<span class="property">current</span> = &#123;</span><br><span class="line">    <span class="comment">// 改变空白填充区域的样式，起始元素的top值就代表起始元素距顶部的距离，可以用来充当paddingTop值</span></span><br><span class="line">    <span class="attr">paddingTop</span>: <span class="string">`<span class="subst">$&#123;dataListRef.current[startIndex].top&#125;</span>px`</span>,</span><br><span class="line">    <span class="comment">// 缓存中最后一个元素的bottom值与endIndex对应元素的bottom值的差值可以用来充当paddingBottom的值</span></span><br><span class="line">    <span class="attr">paddingBottom</span>: <span class="string">`<span class="subst">$&#123;dataListRef.current[dataListRef.current.length - <span class="number">1</span>].bottom - dataListRef.current[endIndex].bottom&#125;</span>px`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setShowList</span>(dataListRef.<span class="property">current</span>.<span class="title function_">slice</span>(startIndex, endIndex + <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者: 唐志远</span><br><span class="line">链接: <span class="attr">https</span>:<span class="comment">//old.fe32.top/articles/xn2023lb/#%E7%9B%91%E5%90%AC%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%8A%A8%E6%80%81%E6%88%AA%E5%8F%96%E6%95%B0%E6%8D%AE-amp-amp-%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE%E4%B8%8A%E4%B8%8B%E7%A9%BA%E7%99%BD%E5%8D%A0%E4%BD%8D</span></span><br><span class="line">来源: 唐志远</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span class="keyword">const</span> <span class="title function_">scrollHandle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取当前要渲染元素的起始索引和结束索引值</span></span><br><span class="line">  <span class="keyword">let</span> &#123; startIndex, endIndex &#125; = <span class="title function_">getIndex</span>()</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果是用户滚动触发的，而且两次startIndex的值都一样，那么就没有必要执行下面的逻辑，</span></span><br><span class="line"><span class="comment">     * 除非是用户重新请求了之后需要默认执行一次该函数，这是一种特殊情况，就是startIndex没变，但需要执行后续的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">if</span> (!isNeedLoad &amp;&amp; lastStartIndex.<span class="property">current</span> === startIndex) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 渲染完一次之后就需要初始化isNeedLoad</span></span><br><span class="line">  isNeedLoad.<span class="property">current</span> = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// 用于实时监控lastStartIndex的值</span></span><br><span class="line">  lastStartIndex.<span class="property">current</span> = startIndex</span><br><span class="line">  <span class="comment">// 下层缓冲区域最后的元素接触到屏幕底部的时候，就可以请求发送数据了</span></span><br><span class="line">  <span class="keyword">const</span> currLen = dataListRef.<span class="property">current</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (endIndex &gt;= currLen - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前不在请求状态下时才可以改变请求参数发送获取更多数据的请求</span></span><br><span class="line">    !isRequestRef.<span class="property">current</span> &amp;&amp; <span class="title function_">setOptions</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123; <span class="attr">offset</span>: state.<span class="property">offset</span> + <span class="number">1</span> &#125;))</span><br><span class="line">    <span class="comment">// 注意endIndex不可以大于缓存中最后一个元素的索引值</span></span><br><span class="line">    endIndex = currLen - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 空白填充区域的样式</span></span><br><span class="line">  topBlankFill.<span class="property">current</span> = &#123;</span><br><span class="line">    <span class="comment">// 改变空白填充区域的样式，起始元素的top值就代表起始元素距顶部的距离，可以用来充当paddingTop值</span></span><br><span class="line">    <span class="attr">paddingTop</span>: <span class="string">`<span class="subst">$&#123;dataListRef.current[startIndex].top&#125;</span>px`</span>,</span><br><span class="line">    <span class="comment">// 缓存中最后一个元素的bottom值与endIndex对应元素的bottom值的差值可以用来充当paddingBottom的值</span></span><br><span class="line">    <span class="attr">paddingBottom</span>: <span class="string">`<span class="subst">$&#123;dataListRef.current[dataListRef.current.length - <span class="number">1</span>].bottom - dataListRef.current[endIndex].bottom&#125;</span>px`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setShowList</span>(dataListRef.<span class="property">current</span>.<span class="title function_">slice</span>(startIndex, endIndex + <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><p>我们虽然实现了根据列表项动态高度下的虚拟列表，但如果列表项中包含图片，并且列表高度由图片撑开。在这种场景下，由于图片会发送网络请求，列表项可能已经渲染到页面中了，但是图片还没有加载出来，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，获取到的高度有无包含图片高度，从而造成计算不准确的情况。</p><p>但是这种任意由图片来撑开盒子大小的场景很少见，因为这样会显得整个列表很不规则。大多数展示图片的列表场景，其实都是提前确定要展示图片的尺寸的，比如微博，1张图片的尺寸是多少，2x2，3x3的尺寸是多少都是提前设计好的，只要我们给img标签加了固定高度，这样就算图片还没有加载出来，但是我们也能够准确的知道列表项的高度是多少。</p><p>如果你真的遇到了这种列表项会由图片任意撑开的场景，可以给图片绑定onload事件，等到它加载完之后再重新计算一下列表的高度，然后把它更新到缓存数据中，这是一种方法。其次，还可以使用ResizeObserver来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度，只不过MDN有说道这只是在实验中的一个功能，所以暂时可能没有办法兼容所有的浏览器！</p><p>如果大家有其它更好的方法，可以在评论区交流哦！</p>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端如何实现自动检测更新？</title>
      <link href="/2024/09/13/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E6%9B%B4%E6%96%B0%EF%BC%9F/"/>
      <url>/2024/09/13/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E6%9B%B4%E6%96%B0%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用户在访问单页面网站时，如果生产环境已经发布了新的版本（有功能上的变化），由于单页面中路由特性或浏览器缓存的原因，并不会重新加载前端资源，此时用户浏览器所并非加载是最新的代码，从而可能遇到一些 bug。<br>那么，在我们部署之后，如何提醒用户版本更新，并引导用户刷新页面呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这里用的【轮询】的方式请求index.html文件，从中解析里面的js文件，由于vue打包后每个js文件都有指纹标识，因此对比每次打包后的指纹，分析文件是否存在变动，如果有变动则提示用户更新！</p><p>环境：vue3 + ts + vite + element-plus<br><img src="/images/post/64dc6f2de4e94.png"></img></p><p>1.在utils文件夹下新建auto-update.ts，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; ElMessageBox &#125; from &#x27;element-plus&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let lastSrcs: any;  //上一次获取到的script地址</span><br><span class="line">let needTip = true; // 默认开启提示</span><br><span class="line"></span><br><span class="line">const scriptReg = /&lt;script.*src=[&quot;&#x27;](?&lt;src&gt;[^&quot;&#x27;]+)/gm;</span><br><span class="line"></span><br><span class="line">const extractNewScripts = async () =&gt; &#123;</span><br><span class="line">    const html = await fetch(&#x27;/?_timestamp=&#x27; + Date.now()).then((resp) =&gt; resp.text());</span><br><span class="line">    scriptReg.lastIndex = 0;</span><br><span class="line">    let result = [];</span><br><span class="line">    let match: RegExpExecArray</span><br><span class="line">    while ((match = scriptReg.exec(html) as RegExpExecArray)) &#123;</span><br><span class="line">        result.push(match.groups?.src)</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const needUpdate = async () =&gt; &#123;</span><br><span class="line">    const newScripts = await extractNewScripts();</span><br><span class="line">    if (!lastSrcs) &#123;</span><br><span class="line">        lastSrcs = newScripts;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    let result = false;</span><br><span class="line">    if (lastSrcs.length !== newScripts.length) &#123;</span><br><span class="line">        result = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0; i &lt; lastSrcs.length; i++) &#123;</span><br><span class="line">        if (lastSrcs[i] !== newScripts[i]) &#123;</span><br><span class="line">            result = true;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastSrcs = newScripts;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">const DURATION = 10000;</span><br><span class="line"></span><br><span class="line">export const autoRefresh = () =&gt; &#123;</span><br><span class="line">    setTimeout(async () =&gt; &#123;</span><br><span class="line">        const willUpdate = await needUpdate();</span><br><span class="line">        if (willUpdate) &#123;</span><br><span class="line">            // 延时更新，防止部署未完成用户就刷新空白</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                ElMessageBox.confirm(&#x27;检测到页面有内容更新，为了功能的正常使用，是否立即刷新？&#x27;, &#x27;更新提示&#x27;, &#123;</span><br><span class="line">                    confirmButtonText: &#x27;确认&#x27;,</span><br><span class="line">                    showCancelButton: false,</span><br><span class="line">                    type: &#x27;warning&#x27;</span><br><span class="line">                &#125;).then(() =&gt; &#123;</span><br><span class="line">                    location.reload();</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;, 30000);</span><br><span class="line">            needTip = false; // 关闭更新提示，防止重复提醒</span><br><span class="line">        &#125;</span><br><span class="line">        if (needTip) &#123;</span><br><span class="line">            autoRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, DURATION)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.关于vite的相关配置，这里只放出rollupOptions相关代码，更多详情请看 build-rollupoptions、Configuration Options</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * @description vite document address</span><br><span class="line"> * https://vitejs.cn/config/ </span><br><span class="line"> */</span><br><span class="line">export default xxx = () =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    base: &#x27;./&#x27;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    server: &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    build: &#123;</span><br><span class="line">      rollupOptions: &#123;</span><br><span class="line">        output: &#123;</span><br><span class="line">          chunkFileNames: &#x27;js/[hash].js&#x27;, // 引入文件名的名称</span><br><span class="line">          entryFileNames: &#x27;js/[hash].js&#x27;, // 包的入口文件名称</span><br><span class="line">          assetFileNames: &#x27;[ext]/[hash].[ext]&#x27;, // 资源文件像 字体，图片等</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在入口文件main.ts中引入autoRefresh，如果是生产环境，则执行autoRefresh方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; autoRefresh &#125; from &quot;@/utils/auto-update&quot;</span><br><span class="line">if (import.meta.env.MODE == &#x27;production&#x27;) &#123;</span><br><span class="line">  autoRefresh()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果你有更好的方案，记得在评论去留言喔~</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>el-date-picker 宽度溢出浏览器问题？</title>
      <link href="/2024/09/10/el-date-picker%20%E5%AE%BD%E5%BA%A6%E6%BA%A2%E5%87%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2024/09/10/el-date-picker%20%E5%AE%BD%E5%BA%A6%E6%BA%A2%E5%87%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-date-picker </span><br><span class="line">    v-model=&quot;Time&quot; type=&quot;datetimerange&quot;</span><br><span class="line">    range-separator=&quot;至&quot;</span><br><span class="line">    start-placeholder=&quot;年/月/日 时:分:秒&quot;</span><br><span class="line">    end-placeholder=&quot;年/月/日 时:分:秒&quot;</span><br><span class="line">    format=&quot;YYYY/MM/DD HH:mm:ss&quot;</span><br><span class="line">    value-format=&quot;YYYY-MM-DD HH:mm:ss&quot;  /&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/post/64ad2e896c5b1.png"></img><br>由上图可见，el-date-picker超出浏览器宽度，导致出现了滚动条。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>利用组件自身的popper-class属性，添加自定义的class。<br><img src="/images/post/64ad2fde21e28.jpg"></img></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-date-picker</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">&quot;Time&quot;</span> <span class="attr">type</span>=<span class="string">&quot;datetimerange&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">range-separator</span>=<span class="string">&quot;至&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">start-placeholder</span>=<span class="string">&quot;年/月/日 时:分:秒&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">end-placeholder</span>=<span class="string">&quot;年/月/日 时:分:秒&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">format</span>=<span class="string">&quot;YYYY/MM/DD HH:mm:ss&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value-format</span>=<span class="string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">popper-class</span>=<span class="string">&quot;tzy-popper&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tzy-popper</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">55px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/post/64ad2e8d86557.png"></img></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6面试题</title>
      <link href="/2024/09/09/ES6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/09/09/ES6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Es6新特性有哪些？"><a href="#Es6新特性有哪些？" class="headerlink" title="Es6新特性有哪些？"></a>Es6新特性有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">变量声明：Const/let</span><br><span class="line">解构拓展</span><br><span class="line">模板字符串</span><br><span class="line">箭头函数</span><br><span class="line">Set/map</span><br><span class="line">Promise</span><br><span class="line">Async/await</span><br><span class="line">Class</span><br><span class="line">Symbol类型‌</span><br></pre></td></tr></table></figure><h2 id="var、let、const之间的区别"><a href="#var、let、const之间的区别" class="headerlink" title="var、let、const之间的区别"></a>var、let、const之间的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html以及css面试题</title>
      <link href="/2024/09/05/html%E4%BB%A5%E5%8F%8Acss%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/09/05/html%E4%BB%A5%E5%8F%8Acss%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC?"></a>什么是BFC?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BFC是一个独立的渲染区域，元素按照一定的规则分布并被计算。</span><br><span class="line">在BFC容器内的元素与外部元素互不影响。</span><br><span class="line">浮动和定位属性页会受到一定的限制。</span><br><span class="line">可以用来清除浮动以及解决高度塌陷等问题。</span><br></pre></td></tr></table></figure><h2 id="Link和-import的区别？"><a href="#Link和-import的区别？" class="headerlink" title="Link和 @import的区别？"></a>Link和 @import的区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提高代码的可读性</span><br><span class="line">在网络卡顿时有良好的页面结构</span><br><span class="line">有利于搜索引擎的seo</span><br><span class="line">Input h1 - h6 header footer aside main</span><br></pre></td></tr></table></figure><h2 id="什么是盒模型？"><a href="#什么是盒模型？" class="headerlink" title="什么是盒模型？"></a>什么是盒模型？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">盒模型分为标准盒模型和怪异盒模型</span><br><span class="line">区别：</span><br><span class="line">是否包含padding，会对connent进行压缩。</span><br></pre></td></tr></table></figure><h2 id="浮动会出现什么问题？"><a href="#浮动会出现什么问题？" class="headerlink" title="浮动会出现什么问题？"></a>浮动会出现什么问题？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">浮动分为左右浮动，会脱离文档流，从而造成高度塌陷。</span><br><span class="line">解决方法：</span><br><span class="line">给其父元素添加overflow：hidden。</span><br><span class="line">添加父元素高度。</span><br><span class="line">使用clear：both。</span><br></pre></td></tr></table></figure><h2 id="项目中你是如何对移动端做适配的？"><a href="#项目中你是如何对移动端做适配的？" class="headerlink" title="项目中你是如何对移动端做适配的？"></a>项目中你是如何对移动端做适配的？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前端做适配没有最好的方法，只有适合的方法，</span><br><span class="line">目前前端做适配的方法有百分比，em，rem，媒体查询，flex布局，vw、vh，</span><br><span class="line">目前在我的项目中用到最多的是rem和flex布局，有时会用到媒体查询，</span><br><span class="line">在px响应式布局时用主要式用手淘的js库flexible.js，移动端则通过rem布局。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Html语义化有什么作用？"><a href="#Html语义化有什么作用？" class="headerlink" title="Html语义化有什么作用？"></a>Html语义化有什么作用？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提高代码的可读性</span><br><span class="line">在网络卡顿时有良好的页面结构</span><br><span class="line">有利于搜索引擎的seo</span><br><span class="line">Input h1 - h6 header footer aside main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面试题</title>
      <link href="/2024/09/01/js%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/09/01/js%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="有哪些数据类型？有什么区别？"><a href="#有哪些数据类型？有什么区别？" class="headerlink" title="有哪些数据类型？有什么区别？"></a>有哪些数据类型？有什么区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数据类型分为基本数据类型以及复杂数据类型</span><br><span class="line">基本数据类型有：</span><br><span class="line">    Number、String、Boolean、Undefined、null、symbol</span><br><span class="line">复杂数据类型有：</span><br><span class="line">    Object、Array、Function</span><br><span class="line">区别：</span><br><span class="line">    简单类型的值存放在栈中，在栈中存放的是对应的值</span><br><span class="line">    引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="和-区别？"><a href="#和-区别？" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别？"></a>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">等于：</span><br><span class="line">    两个都为简单类型，字符串和布尔值都会转换成数值，再比较</span><br><span class="line">    简单类型与引用类型比较，对象转化成其原始类型的值，</span><br><span class="line">    再比较两个都为引用类型，则比较它们是否指向同一个对象</span><br><span class="line">    null 和 undefined 相等</span><br><span class="line">    存在 NaN 则返回 false</span><br><span class="line">全等于：</span><br><span class="line">    两个操作数在不转换的前提下相等才返回true，即类型相同，值也需相同</span><br><span class="line">区别：</span><br><span class="line">    相等操作符(==)会做类型转换，再进行值的比较，全等运算符不会做类型转换</span><br><span class="line">    null和undefined 比较，相等操作符(==)为true，全等为false</span><br></pre></td></tr></table></figure><h2 id="typeof-与-instanceof-区别？"><a href="#typeof-与-instanceof-区别？" class="headerlink" title="typeof 与 instanceof 区别？"></a>typeof 与 instanceof 区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeof：用于检查基本数据类型和函数</span><br><span class="line">    无法准确识别数组类型，它将数组也归类为&quot;object&quot;</span><br><span class="line">    无法准确识别null类型，它将null也归类为&quot;object&quot;</span><br><span class="line">instanceof：用于检查对象是否是特定类（构造函数）的实例</span><br><span class="line"></span><br><span class="line">Typeof和instanceof，typeof可以判断number、strng、undefined、boolean、symbol</span><br><span class="line">Function。Instanceof可以判断复杂数据类型，是根据原型链进行的判断，如果需要判断数据类型可以用objject.Prototype.toString判断。</span><br></pre></td></tr></table></figure><h2 id="apply-call-bind-区别？"><a href="#apply-call-bind-区别？" class="headerlink" title="apply call bind 区别？"></a>apply call bind 区别？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">都可以改变函数的 this 对象指向</span><br><span class="line">apply 接受两个参数，第一个参数是 this 的指向，第二个参数是函数接受的参数，以数组的形式传入</span><br><span class="line">call方法的第一个参数也是 this 的指向，后面传入的是一个参数列表</span><br><span class="line">bind方法和cal很相似，第一参数也是 this 的指向，后面传入的也是一个参数列表(可以分多次传入)</span><br><span class="line">bind是返回绑定之后的函数，apply、call则是立即执行</span><br></pre></td></tr></table></figure><h2 id="什么是闭包？会出现什么问题？"><a href="#什么是闭包？会出现什么问题？" class="headerlink" title="什么是闭包？会出现什么问题？"></a>什么是闭包？会出现什么问题？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建私有变量</span><br><span class="line">延长变量的生命周期</span><br><span class="line">会造成内存泄露</span><br><span class="line"></span><br><span class="line">闭包是内部函数可以访问外部函数作用域中的变量，即使外部函数已经执行完毕，这些变量仍然可以被内部函数中引用。</span><br><span class="line">应用场景：</span><br><span class="line">封装私有变量：通过使用闭包，可以创建包含私有变量的函数并将相关的方法作为闭包返回，从而实现私有变量的封装。这样可以避免变量被外部访问和修改，同时暴露一些方法来操作这些私有变量。</span><br><span class="line">回调函数：闭包常用于创建回调函数，将函数作为参数传递给其他函数，并在适当的使用。通过闭包，可以外部环境的状态或数据传递给回调函数，使其能够访问并操作外部环境中的变量。</span><br><span class="line">模块化开发：通过使用闭包，可以实现模块化的代码结构。将相关的函数和变量封装在闭包中，暴露出一些公共接口供外部使用，从而实现模块化的开发和组织代码。</span><br><span class="line">记忆和缓存：闭包可以用于创建记忆和缓存机制。通过闭包中存储的计算结果或数据，可以避免重复计算或数据请求，提高性能。</span><br></pre></td></tr></table></figure><h2 id="深拷贝浅拷贝的区别-如何实现一个深拷贝"><a href="#深拷贝浅拷贝的区别-如何实现一个深拷贝" class="headerlink" title="深拷贝浅拷贝的区别?如何实现一个深拷贝?"></a>深拷贝浅拷贝的区别?如何实现一个深拷贝?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝仅复制对象的第一层数据</span><br><span class="line">深拷贝则递归复制所有层级，确保新对象与原对象完全独立，修改新对象不会影响原对象</span><br><span class="line">实现深拷贝：</span><br><span class="line">    JSON方法：</span><br><span class="line">        JSON.parse(JSON.stringify(obj))</span><br><span class="line">    递归复制</span><br><span class="line">    使用第三方库lodash：</span><br><span class="line">        _.cloneDeep()</span><br></pre></td></tr></table></figure><h2 id="数组和对象的方法"><a href="#数组和对象的方法" class="headerlink" title="数组和对象的方法?"></a>数组和对象的方法?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Push </span><br><span class="line">pop </span><br><span class="line">shift </span><br><span class="line">unshift </span><br><span class="line">splice </span><br><span class="line">slice</span><br><span class="line">Object.keys </span><br><span class="line">object.values </span><br><span class="line">object.entries</span><br></pre></td></tr></table></figure><h2 id="JavaScript本地存储的方式有哪些，有什么区别"><a href="#JavaScript本地存储的方式有哪些，有什么区别" class="headerlink" title="JavaScript本地存储的方式有哪些，有什么区别?"></a>JavaScript本地存储的方式有哪些，有什么区别?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">本地存储主要有三种方式：‌cookie‌、‌sessionStorage‌、和‌localStorage‌。</span><br><span class="line">‌   cookie‌：主要用于识别用户身份，存储量小，一般为4KB左右，且每次请求都会被发送到服务器,</span><br><span class="line">   存在安全风险。默认有效期为会话级别，但可以手动设置过期时间。</span><br><span class="line">        用途：标记用户与跟踪用户行为的情况</span><br><span class="line">   ‌sessionStorage‌：会话存储,一般为5M左右，仅在当前会话期间有效，浏览器关闭后数据即被清除。可以跨页面通讯，但仅限于同一浏览器窗口中的页面。</span><br><span class="line">        用途：适合长期保存在本地的数据(令牌)</span><br><span class="line">   ‌localStorage‌：长期存储,一般为5M左右，数据将一直保存在浏览器中，除非手动删除或清除浏览器缓存。容量较大，约为5MB，且可以跨窗口（页面）共享数据。</span><br><span class="line">        用途：敏感账号一次性登录</span><br><span class="line">   indexedDB : 可以存储大量数据。</span><br><span class="line">        用途：存储大量数据的情况、在线文档(富文本编辑器)保存编辑历史的情况</span><br></pre></td></tr></table></figure><h2 id="什么是防抖和节流-有什么区别-如何实现"><a href="#什么是防抖和节流-有什么区别-如何实现" class="headerlink" title="什么是防抖和节流?有什么区别?如何实现?"></a>什么是防抖和节流?有什么区别?如何实现?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">防抖和节流是JavaScript中优化高频率触发事件的技术，它们都能减少不必要的函数调用，提高应用程序性能，但实现方式和应用场景有所不同‌。</span><br><span class="line">防抖（Debounce）‌：在指定时间内，事件处理函数只执行一次。如果在这个时间段内又触发了事件，那么会重新计算执行时间。</span><br><span class="line">    搜索框搜索输入。只需用户最后一次输入完，再发送请求</span><br><span class="line">    手机号、邮箱验证输入检测</span><br><span class="line">    窗口大小 resize 。只需窗口调整完成后，计算窗口大小。防止重复染。</span><br><span class="line">节流（Throttle）‌：允许一个函数在一定时间内只执行一次，无论这个时间内触发了多少次事件。</span><br><span class="line">    滚动加载，加载更多或滚到底部监听</span><br><span class="line">    搜索框，搜索联想功能</span><br></pre></td></tr></table></figure><h2 id="Promise解决了什么问题"><a href="#Promise解决了什么问题" class="headerlink" title="Promise解决了什么问题?"></a>Promise解决了什么问题?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决回调地狱，统一异步的实现方案</span><br></pre></td></tr></table></figure><h2 id="Promise-all和race的区别"><a href="#Promise-all和race的区别" class="headerlink" title="Promise all和race的区别?"></a>Promise all和race的区别?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All全部成功返回</span><br><span class="line">Race 赛跑</span><br></pre></td></tr></table></figure><h2 id="Async和await"><a href="#Async和await" class="headerlink" title="Async和await?"></a>Async和await?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Async返回一个promise</span><br><span class="line">Await等待</span><br></pre></td></tr></table></figure><h2 id="Get和post的差异"><a href="#Get和post的差异" class="headerlink" title="Get和post的差异?"></a>Get和post的差异?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般我们用get请求数据用post发生数据，get都在url中所以会有长度的限制，post可以发送大量的数据。安全方面的话由于post没有量的限制，可以进行加密，所以更为安全。</span><br></pre></td></tr></table></figure><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝?"></a>深浅拷贝?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝会赋值最外层的属性及赋值，深拷贝会赋值每一层的数据和值，通过遍历每一层实现深拷贝。</span><br></pre></td></tr></table></figure><h2 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="headerlink" title="如何实现深拷贝?"></a>如何实现深拷贝?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过递归的方式，正反序列</span><br></pre></td></tr></table></figure><h2 id="Git-如何处理冲突"><a href="#Git-如何处理冲突" class="headerlink" title="Git 如何处理冲突?"></a>Git 如何处理冲突?</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash 隐藏</span><br><span class="line">git pull 拉取</span><br><span class="line">git stash pop 显示</span><br><span class="line">在本地解决冲突</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外置标签写法汇总</title>
      <link href="/2024/08/30/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E7%BD%AE%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2024/08/30/Markdown%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%A4%96%E7%BD%AE%E6%A0%87%E7%AD%BE%E5%86%99%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-语法自带格式"><a href="#Markdown-语法自带格式" class="headerlink" title="Markdown 语法自带格式"></a>Markdown 语法自带格式</h1><!-- <div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown 语法图文全面详解(10 分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在 CSS 冲突问题!</p></div> --><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch;</span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch;</span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="多级标题"><a href="#多级标题" class="headerlink" title="多级标题"></a>多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<del>删除</del>线演示</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown 语法】字体颜色大小及文字底色设置</a></p></div><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>….</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><hr></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="列表-跟空格都可以"><a href="#列表-跟空格都可以" class="headerlink" title="列表(*,+,-跟空格都可以)"></a>列表(*,+,-跟空格都可以)</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span></span><br><span class="line"><span class="bullet">2.</span></span><br><span class="line"><span class="bullet">3.</span></span><br><span class="line">4.</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">code</span>](<span class="link">/img/1720007073.webp</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><p><img src="/img/1720007073.webp" alt="code"></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">示例源码</button><button type="button" class="tab " data-href="分栏-2">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)&#x3D;\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h1 id="Butterfly-外置标签"><a href="#Butterfly-外置标签" class="headerlink" title="Butterfly 外置标签"></a>Butterfly 外置标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://blog.anheyu.com/posts/d50a.html">安知鱼主题标签 Tag Plugins</a></p></div><h2 id="引用-note"><a href="#引用-note" class="headerlink" title="引用 note"></a>引用 note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">通用配置</button><button type="button" class="tab " data-href="分栏-2">语法格式</button><button type="button" class="tab " data-href="分栏-3">参数配置</button><button type="button" class="tab " data-href="分栏-4">示例源码</button><button type="button" class="tab " data-href="分栏-5">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: flat</span><br><span class="line">  icons: true</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-3"><p>1.自带 icon</p><table><thead><tr><th>参数</th><th align="center">用法</th></tr></thead><tbody><tr><td>class</td><td align="center">【可选】标识，不同的标识有不同的配色 （ default &#x2F; primary &#x2F; success &#x2F; info &#x2F; warning &#x2F; danger ）</td></tr><tr><td>no-icon</td><td align="center">【可选】不显示 icon</td></tr><tr><td>style</td><td align="center">【可选】可以覆盖配置中的 style （simple&#x2F;modern&#x2F;flat&#x2F;disabled）</td></tr></tbody></table><p>2.外部 icon</p><table><thead><tr><th>参数</th><th align="center">用法</th></tr></thead><tbody><tr><td>class</td><td align="center">【可选】标识，不同的标识有不同的配色 （ default &#x2F; blue &#x2F; pink &#x2F; red &#x2F; purple &#x2F; orange &#x2F; green ）</td></tr><tr><td>no-icon</td><td align="center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td align="center">【可选】可以覆盖配置中的 style （simple&#x2F;modern&#x2F;flat&#x2F;disabled）</td></tr></tbody></table></div><div class="tab-item-content" id="分栏-4"><details class="toggle" style="border: 1px solid blue"><summary class="toggle-button" style="background-color: blue;">1.自带icon</summary><div class="toggle-content"><p> 1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div></details><details class="toggle" style="border: 1px solid  blue"><summary class="toggle-button" style="background-color:  blue;">2.外部icon</summary><div class="toggle-content"><p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021 年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021 年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021 年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021 年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021 年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div></details></div><div class="tab-item-content" id="分栏-5"><details class="toggle" style="border: 1px solid  blue"><summary class="toggle-button" style="background-color:  blue;">1.自带icon</summary><div class="toggle-content"><p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div><p>2.<code>modern</code>样式</p><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div></div></details><details class="toggle" style="border: 1px solid  blue"><summary class="toggle-button" style="background-color:  blue;">2.外部icon</summary><div class="toggle-content"><p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021 年快到了….</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021 年快到了….</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021 年快到了….</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021 年快到了….</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021 年快到了….</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div></div></details></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="时间轴-timeline"><a href="#时间轴-timeline" class="headerlink" title="时间轴 timeline"></a>时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">配置参数</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题&#x2F;时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) &#x2F; blue &#x2F; pink &#x2F; red &#x2F; purple &#x2F; orange &#x2F; green</li></ol></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="相册-gallery"><a href="#相册-gallery" class="headerlink" title="相册 gallery"></a>相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">参数配置</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的 Gallery 相册,新的 Gallery 相册会自动根据图片长度进行排版，书写也更加方便，与 markdown 格式一样。可根据需要插入到相应的 md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main"><figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure>  </div>2.gallery 相册<div class="gallery-container" data-type="data" data-button="">      <div class="gallery-data">[{"url":"https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg","alt":""},{"url":"https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg","alt":""}]</div>      <div class="gallery-items">      </div>    </div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="分栏-tab"><a href="#分栏-tab" class="headerlink" title="分栏 tab"></a>分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">配置参数</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line"></span><br><span class="line">Any content (support inline tags too).</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id 中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子&#x2F;页面的 URL 必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果 index 为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome 图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择 tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义 Tab 名 + 只有 icon + icon 和 Tab 名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**tab 名字为第一个 Tab**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**只有图标 没有 Tab 名字**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"></span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test1-1">test1 1</button><button type="button" class="tab " data-href="test1-2">test1 2</button><button type="button" class="tab " data-href="test1-3">test1 3</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>2.Demo 2 - 预设选择 tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><button type="button" class="tab " data-href="test2-1">test2 1</button><button type="button" class="tab " data-href="test2-2">test2 2</button><button type="button" class="tab  active" data-href="test2-3">test2 3</button></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs no-default"><button type="button" class="tab " data-href="test3-1">test3 1</button><button type="button" class="tab " data-href="test3-2">test3 2</button><button type="button" class="tab " data-href="test3-3">test3 3</button></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>4.Demo 4 - 自定义 Tab 名 + 只有 icon + icon 和 Tab 名</p><div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">第一个Tab</button><button type="button" class="tab " data-href="test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button><button type="button" class="tab " data-href="test4-3"><i class="fas fa-bomb"></i>炸弹</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab 名字为第一个 Tab</strong></p></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有 Tab 名字</strong></p></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="隐藏块"><a href="#隐藏块" class="headerlink" title="隐藏块"></a>隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="分栏-1">标签语法</button><button type="button" class="tab " data-href="分栏-2">参数配置</button><button type="button" class="tab " data-href="分栏-3">示例源码</button><button type="button" class="tab " data-href="分栏-4">渲染演示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://registry.npmmirror.com/js-asuna/latest/files/pic/Asuna/Asuna16x9.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Asuna&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://registry.npmmirror.com/js-asuna/latest/files/pic/Asuna/Asuna16x9.webp" alt="Asuna" /></p></div></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 外置标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
